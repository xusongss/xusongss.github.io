<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="第三章 高级请求-应答模式在第二章中我们通过开发一系列的小应用来熟悉ØMQ的基本使用方法，每个应用会引入一些新的特性。本章会沿用这种方式，来探索更多建立在ØMQ请求-应答模式之上的高级工作模式。 本章涉及的内容有：  在请求-应答模式中创建和使用消息信封 使用REQ、REP、DEALER和ROUTER套接字 使用标识来手工指定应答目标 使用自定义离散路由模式 使用自定义最近最少使用路由模式 构建高">
<meta name="keywords">
<meta property="og:type" content="article">
<meta property="og:title" content="zmq-chapter3">
<meta property="og:url" content="http://yoursite.com/2017/03/02/zmq-chapter3/index.html">
<meta property="og:site_name" content="绿色回忆">
<meta property="og:description" content="第三章 高级请求-应答模式在第二章中我们通过开发一系列的小应用来熟悉ØMQ的基本使用方法，每个应用会引入一些新的特性。本章会沿用这种方式，来探索更多建立在ØMQ请求-应答模式之上的高级工作模式。 本章涉及的内容有：  在请求-应答模式中创建和使用消息信封 使用REQ、REP、DEALER和ROUTER套接字 使用标识来手工指定应答目标 使用自定义离散路由模式 使用自定义最近最少使用路由模式 构建高">
<meta property="og:updated_time" content="2017-04-28T05:42:32.975Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zmq-chapter3">
<meta name="twitter:description" content="第三章 高级请求-应答模式在第二章中我们通过开发一系列的小应用来熟悉ØMQ的基本使用方法，每个应用会引入一些新的特性。本章会沿用这种方式，来探索更多建立在ØMQ请求-应答模式之上的高级工作模式。 本章涉及的内容有：  在请求-应答模式中创建和使用消息信封 使用REQ、REP、DEALER和ROUTER套接字 使用标识来手工指定应答目标 使用自定义离散路由模式 使用自定义最近最少使用路由模式 构建高">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/03/02/zmq-chapter3/"/>





  <title>zmq-chapter3 | 绿色回忆</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">绿色回忆</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">程序猿 攻城狮</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/02/zmq-chapter3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="徐松">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="绿色回忆">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                zmq-chapter3
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-02T00:00:22+08:00">
                2017-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="第三章-高级请求-应答模式"><a href="#第三章-高级请求-应答模式" class="headerlink" title="第三章 高级请求-应答模式"></a>第三章 高级请求-应答模式</h2><p>在第二章中我们通过开发一系列的小应用来熟悉ØMQ的基本使用方法，每个应用会引入一些新的特性。本章会沿用这种方式，来探索更多建立在ØMQ请求-应答模式之上的高级工作模式。</p>
<p>本章涉及的内容有：</p>
<ul>
<li>在请求-应答模式中创建和使用消息信封</li>
<li>使用REQ、REP、DEALER和ROUTER套接字</li>
<li>使用标识来手工指定应答目标</li>
<li>使用自定义离散路由模式</li>
<li>使用自定义最近最少使用路由模式</li>
<li>构建高层消息封装类</li>
<li>构建基本的请求应答代理</li>
<li>合理命名套接字</li>
<li>模拟client-worker集群</li>
<li>构建可扩展的请求-应答集群云</li>
<li>使用管道套接字监控线程<a id="more"></a>
<h3 id="Request-Reply-Envelopes"><a href="#Request-Reply-Envelopes" class="headerlink" title="Request-Reply Envelopes"></a>Request-Reply Envelopes</h3></li>
</ul>
<p>在请求-应答模式中，信封里保存了应答目标的位置。这就是为什么ØMQ网络虽然是无状态的，但仍能完成请求-应答的过程。</p>
<p>在一般使用过程中，你并不需要知道请求-应答信封的工作原理。使用REQ、REP时，ØMQ会自动处理消息信封。下一章讲到的装置（device），使用时也只需保证读取和写入所有的信息即可。ØMQ使用多段消息的方式来存储信封，所以在复制消息时也会复制信封。</p>
<p>然而，在使用高级请求-应答模式之前是需要了解信封这一机制的，以下是信封机制在ROUTER中的工作原理：</p>
<ul>
<li>从ROUTER中读取一条消息时，ØMQ会包上一层信封，上面注明了消息的来源。</li>
<li>向ROUTER写入一条消息时（包含信封），ØMQ会将信封拆开，并将消息递送给相应的对象。</li>
</ul>
<p>如果将从ROUTER A中获取的消息（包含信封）写入ROUTER B（即将消息发送给一个DEALER，该DEALER连接到了ROUTER），那么在从ROUTER B中获取该消息时就会包含两层信封。</p>
<p>信封机制的根本作用是让ROUTER知道如何将消息递送给正确的应答目标，你需要做的就是在程序中保留好该信封。回顾一下REP套接字，它会将收到消息的信封逐个拆开，将消息本身传送给应用程序。而在发送时，又会在消息外层包裹该信封，发送给ROUTER，从而传递给正确的应答目标。</p>
<p>我们可以使用上述原理建立起一个ROUTER-DEALER装置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[REQ] &lt;--&gt; [REP]</div><div class="line">[REQ] &lt;--&gt; [ROUTER--DEALER] &lt;--&gt; [REP]</div><div class="line">[REQ] &lt;--&gt; [ROUTER--DEALER] &lt;--&gt; [ROUTER--DEALER] &lt;--&gt; [REP]</div><div class="line">...etc.</div></pre></td></tr></table></figure>
<p>当你用REQ套接字去连接ROUTER套接字，并发送一条请求消息，你会从ROUTER中获得一条如下所示的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          +---------------+</div><div class="line">Frame 1   | Reply address |   &lt;----- Envelope</div><div class="line">          +---+-----------+</div><div class="line">Frame 2   |   |   &lt;------ Empty message part</div><div class="line">          +---+-------------------------------------+</div><div class="line">Frame 3   | Data                                    |</div><div class="line">          +-----------------------------------------+</div><div class="line"></div><div class="line"></div><div class="line">     Figure # - Single-hop request-reply envelope</div></pre></td></tr></table></figure>
<ul>
<li>第三帧是应用程序发送给REQ套接字的消息；</li>
<li>第二帧的空信息是REQ套接字在发送消息给ROUTER之前添加的；</li>
<li>第一帧即信封，是由ROUTER套接字添加的，记录了消息的来源。</li>
</ul>
<p>如果我们在一条装置链路上传递该消息，最终会得到包含多层信封的消息。最新的信封会在消息的顶部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">     (Next envelope will go here)</div><div class="line"></div><div class="line">          +---------------+</div><div class="line">Frame 1   | Reply address |   &lt;----- Envelope (ROUTER)</div><div class="line">          +---------------+</div><div class="line">Frame 2   | Reply address |   &lt;----- Envelope (ROUTER)</div><div class="line">          +---------------+</div><div class="line">Frame 3   | Reply address |   &lt;----- Envelope (ROUTER)</div><div class="line">          +---+-----------+</div><div class="line">Frame 4   |   |   &lt;------ Empty message part (REQ)</div><div class="line">          +---+-------------------------------------+</div><div class="line">Frame 5   | Data                                    |</div><div class="line">          +-----------------------------------------+</div><div class="line"></div><div class="line"></div><div class="line">     Figure # - Multihop request-reply envelope</div></pre></td></tr></table></figure>
<p>以下将详述我们在请求-应答模式中使用到的四种套接字类型：</p>
<ul>
<li><p>DEALER是一种负载均衡，它会将消息分发给已连接的节点，并使用公平队列的机制处理接受到的消息。DEALER的作用就像是PUSH和PULL的结合。</p>
</li>
<li><p>REQ发送消息时会在消息顶部插入一个空帧，接受时会将空帧移去。其实REQ是建立在DEALER之上的，但REQ只有当消息发送并接受到回应后才能继续运行。</p>
</li>
<li><p>ROUTER在收到消息时会在顶部添加一个信封，标记消息来源。发送时会通过该信封决定哪个节点可以获取到该条消息。</p>
</li>
<li><p>REP在收到消息时会将第一个空帧之前的所有信息保存起来，将原始信息传送给应用程序。在发送消息时，REP会用刚才保存的信息包裹应答消息。REP其实是建立在ROUTER之上的，但和REQ一样，必须完成接受和发送这两个动作后才能继续。</p>
</li>
</ul>
<p>REP要求消息中的信封由一个空帧结束，所以如果你没有用REQ发送消息，则需要自己在消息中添加这个空帧。</p>
<p>你肯定会问，ROUTER是怎么标识消息的来源的？答案当然是套接字的标识。我们之前讲过，一个套接字可能是瞬时的，它所连接的套接字（如ROUTER）则会给它生成一个标识，与之相关联。一个套接字也可以显式地给自己定义一个标识，这样其他套接字就可以直接使用了。</p>
<p>这是一个瞬时的套接字，ROUTER会自动生成一个UUID来标识消息的来源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">+-----------+</div><div class="line">|           |</div><div class="line">|   Client  |</div><div class="line">|           |</div><div class="line">+-----------+       +---------+</div><div class="line">|    REQ    |       |  Data   |     Client sends this</div><div class="line">\-----+-----/       +---------+</div><div class="line">      |</div><div class="line">      |  &quot;My identity is empty&quot;</div><div class="line">      v</div><div class="line">/-----------\       +---------+</div><div class="line">|  ROUTER   |       |  UUID   |     ROUTER invents UUID to</div><div class="line">+-----------+       +-+-------+     use as reply address</div><div class="line">|           |       | |</div><div class="line">|  Service  |       +-+-------+</div><div class="line">|           |       |  Data   |</div><div class="line">+-----------+       +---------+</div><div class="line"></div><div class="line"></div><div class="line">  Figure # - ROUTER invents a UUID for transient sockets</div></pre></td></tr></table></figure>
<p>这是一个持久的套接字，标识由消息来源自己指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">+-----------+</div><div class="line">|           |       zmq_setsockopt (socket,</div><div class="line">|   Client  |           ZMQ_IDENTITY, &quot;Lucy&quot;, 4);</div><div class="line">|           |</div><div class="line">+-----------+       +---------+</div><div class="line">|    REQ    |       |  Data   |     Client sends this</div><div class="line">\-----+-----/       +---------+</div><div class="line">      |</div><div class="line">      |  &quot;Hi, my name is Lucy&quot;</div><div class="line">      v</div><div class="line">/-----------\       +---------+</div><div class="line">|  ROUTER   |       | &apos;Lucy&apos;  |     ROUTER uses identity of</div><div class="line">+-----------+       +-+-------+     client as reply address</div><div class="line">|           |       | |</div><div class="line">|  Service  |       +-+-------+</div><div class="line">|           |       |  Data   |</div><div class="line">+-----------+       +---------+</div><div class="line"></div><div class="line"></div><div class="line">   Figure # - ROUTER uses identity if it knows it</div></pre></td></tr></table></figure>
<p>下面让我们在实例中观察上述两种操作。下列程序会打印出ROUTER从两个REP套接字中获得的消息，其中一个没有指定标识，另一个指定了“Hello”作为标识。</p>
<p><strong>identity.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 以下程序演示了如何在请求-应答模式中使用套接字标识。</span></div><div class="line"><span class="comment">// 需要注意的是s_开头的函数是由zhelpers.h提供的。</span></div><div class="line"><span class="comment">// 我们没有必要重复编写那些代码。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zhelpers.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *context = zmq_init (<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">void</span> *sink = zmq_socket (context, ZMQ_ROUTER);</div><div class="line">    zmq_bind (sink, <span class="string">"inproc://example"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 第一个套接字由0MQ自动设置标识</span></div><div class="line">    <span class="keyword">void</span> *anonymous = zmq_socket (context, ZMQ_REQ);</div><div class="line">    zmq_connect (anonymous, <span class="string">"inproc://example"</span>);</div><div class="line">    s_send (anonymous, <span class="string">"ROUTER uses a generated UUID"</span>);</div><div class="line">    s_dump (sink);</div><div class="line"></div><div class="line">    <span class="comment">// 第二个由自己设置</span></div><div class="line">    <span class="keyword">void</span> *identified = zmq_socket (context, ZMQ_REQ);</div><div class="line">    zmq_setsockopt (identified, ZMQ_IDENTITY, <span class="string">"Hello"</span>, <span class="number">5</span>);</div><div class="line">    zmq_connect (identified, <span class="string">"inproc://example"</span>);</div><div class="line">    s_send (identified, <span class="string">"ROUTER socket uses REQ's socket identity"</span>);</div><div class="line">    s_dump (sink);</div><div class="line"></div><div class="line">    zmq_close (sink);</div><div class="line">    zmq_close (anonymous);</div><div class="line">    zmq_close (identified);</div><div class="line">    zmq_term (context);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">----------------------------------------</div><div class="line">[017] 00314F043F46C441E28DD0AC54BE8DA727</div><div class="line">[000]</div><div class="line">[026] ROUTER uses a generated UUID</div><div class="line">----------------------------------------</div><div class="line">[005] Hello</div><div class="line">[000]</div><div class="line">[038] ROUTER socket uses REQ&apos;s socket identity</div></pre></td></tr></table></figure>
<h3 id="自定义请求-应答路由"><a href="#自定义请求-应答路由" class="headerlink" title="自定义请求-应答路由"></a>自定义请求-应答路由</h3><p>我们已经看到ROUTER套接字是如何使用信封将消息发送给正确的应答目标的，下面我们从一个角度来定义ROUTER：在发送消息时使用一定格式的信封提供正确的路由目标，ROUTER就能够将该条消息异步地发送给对应的节点。</p>
<p>所以说ROUTER的行为是完全可控的。在深入理解这一特性之前，让我们先近距离观察一下REQ和REP套接字，赋予他们一些鲜活的角色：</p>
<ul>
<li>REQ是一个“妈妈”套接字，不会耐心听别人说话，但会不断地抛出问题寻求解答。REQ是严格同步的，它永远位于消息链路的请求端；</li>
<li>REP则是一个“爸爸”套接字，只会回答问题，不会主动和别人对话。REP也是严格同步的，并一直位于应答端。</li>
</ul>
<p>关于“妈妈”套接字，正如我们小时候所经历的，只能等她向你开口时你们才能对话。妈妈不像爸爸那么开明，也不会像DEALER套接字一样接受模棱两可的回答。所以，想和REQ套接字对话只有等它主动发出请求后才行，之后它就会一直等待你的回答，不管有多久。</p>
<p>“爸爸”套接字则给人一种强硬、冷漠的感觉，他只做一件事：无论你提出什么问题，都会给出一个精确的回答。不要期望一个REP套接字会主动和你对话或是将你俩的交谈传达给别人，它不会这么做的。</p>
<p>我们通常认为请求-应答模式一定是有来有往、有去有回的过程，但实际上这个过程是可以异步进行的。我们只需获得相应节点的地址，即可通过ROUTER套接字来异步地发送消息。ROUTER是ZMQ中唯一一个可以定位消息来源的套接字。</p>
<p>我们对请求-应答模式下的路由做一个小结：</p>
<ul>
<li>对于瞬时的套接字，ROUTER会动态生成一个UUID来标识它，因此从ROUTER中获取到的消息里会包含这个标识；</li>
<li>对于持久的套接字，可以自定义标识，ROUTER会如直接将该标识放入消息之中；</li>
<li>具有显式声明标识的节点可以连接到其他类型的套接字；</li>
<li>节点可以通过配置文件等机制提前获知对方节点的标识，作出相应的处理。</li>
</ul>
<p>我们至少有三种模式来实现和ROUTER的连接：</p>
<ul>
<li>ROUTER-DEALER</li>
<li>ROUTER-REQ</li>
<li>ROUTER-REP</li>
</ul>
<p>每种模式下我们都可以完全掌控消息的路由方式，但不同的模式会有不一样的应用场景和消息流，下一节开始我们会逐一解释。</p>
<p>自定义路由也有一些注意事项：</p>
<ul>
<li>自定义路由让节点能够控制消息的去向，这一点有悖ØMQ的规则。使用自定义路由的唯一理由是ØMQ缺乏更多的路由算法供我们选择；</li>
<li>未来的ØMQ版本可能包含一些我们自定义的路由方式，这意味着我们现在设计的代码可能无法在新版本的ØMQ中运行，或者成为一种多余；</li>
<li>内置的路由机制是可扩展的，且对装置友好，但自定义路由就需要自己解决这些问题。</li>
</ul>
<p>所以说自定义路由的成本是比较高的，更多情况下应当交由ØMQ来完成。不过既然我们已经讲到这儿了，就继续深入下去吧！</p>
<h3 id="ROUTER-DEALER路由"><a href="#ROUTER-DEALER路由" class="headerlink" title="ROUTER-DEALER路由"></a>ROUTER-DEALER路由</h3><p>ROUTER-DEALDER是一种最简单的路由方式。将ROUTER和多个DEALER相连接，用一种合适的算法来决定如何分发消息给DEALER。DEALER可以是一个黑洞（只负责处理消息，不给任何返回）、代理（将消息转发给其他节点）或是服务（会发送返回信息）。</p>
<p>如果你要求DEALER能够进行回复，那就要保证只有一个ROUTER连接到DEALER，因为DEALER并不知道哪个特定的节点在联系它，如果有多个节点，它会做负载均衡，将消息分发出去。但如果DEALER是一个黑洞，那就可以连接任何数量的节点。</p>
<p>ROUTER-DEALER路由可以用来做什么呢？如果DEALER会将它完成任务的时间回复给ROUTER，那ROUTER就可以知道这个DEALER的处理速度有多快了。因为ROUTER和DEALER都是异步的套接字，所以我们要用zmq_poll()来处理这种情况。</p>
<p>下面例子中的两个DEALER不会返回消息给ROUTER，我们的路由采用加权随机算法：发送两倍多的信息给其中的一个DEALER。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">       +-------------+</div><div class="line">       |             |</div><div class="line">       |   Client    |  Send to &quot;A&quot; or &quot;B&quot;</div><div class="line">       |             |</div><div class="line">       +-------------+</div><div class="line">       |   ROUTER    |</div><div class="line">       \------+------/</div><div class="line">              |</div><div class="line">              |</div><div class="line">      +-------+-------+</div><div class="line">      |               |</div><div class="line">      |               |</div><div class="line">      v               v</div><div class="line">/-----------\   /-----------\</div><div class="line">|  DEALER   |   |  DEALER   |</div><div class="line">|    &quot;A&quot;    |   |    &quot;B&quot;    |</div><div class="line">+-----------+   +-----------+</div><div class="line">|           |   |           |</div><div class="line">|  Worker   |   |   Worker  |</div><div class="line">|           |   |           |</div><div class="line">+-----------+   +-----------+</div><div class="line"></div><div class="line"></div><div class="line">Figure # - Router to dealer custom routing</div></pre></td></tr></table></figure>
<p><strong>rtdealer.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 自定义ROUTER-DEALER路由</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 这个实例是单个进程，这样方便启动。</span></div><div class="line"><span class="comment">// 每个线程都有自己的ZMQ上下文，所以可以认为是多个进程在运行。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zhelpers.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 这里定义了两个worker，其代码是一样的。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">worker_task_a</span> <span class="params">(<span class="keyword">void</span> *args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *context = zmq_init (<span class="number">1</span>);</div><div class="line">    <span class="keyword">void</span> *worker = zmq_socket (context, ZMQ_DEALER);</div><div class="line">    zmq_setsockopt (worker, ZMQ_IDENTITY, <span class="string">"A"</span>, <span class="number">1</span>);</div><div class="line">    zmq_connect (worker, <span class="string">"ipc://routing.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 我们只接受到消息的第二部分</span></div><div class="line">        <span class="keyword">char</span> *request = s_recv (worker);</div><div class="line">        <span class="keyword">int</span> finished = (<span class="built_in">strcmp</span> (request, <span class="string">"END"</span>) == <span class="number">0</span>);</div><div class="line">        <span class="built_in">free</span> (request);</div><div class="line">        <span class="keyword">if</span> (finished) &#123;</div><div class="line">            <span class="built_in">printf</span> (<span class="string">"A received: %d\n"</span>, total);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        total++;</div><div class="line">    &#125;</div><div class="line">    zmq_close (worker);</div><div class="line">    zmq_term (context);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">worker_task_b</span> <span class="params">(<span class="keyword">void</span> *args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *context = zmq_init (<span class="number">1</span>);</div><div class="line">    <span class="keyword">void</span> *worker = zmq_socket (context, ZMQ_DEALER);</div><div class="line">    zmq_setsockopt (worker, ZMQ_IDENTITY, <span class="string">"B"</span>, <span class="number">1</span>);</div><div class="line">    zmq_connect (worker, <span class="string">"ipc://routing.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 我们只接受到消息的第二部分</span></div><div class="line">        <span class="keyword">char</span> *request = s_recv (worker);</div><div class="line">        <span class="keyword">int</span> finished = (<span class="built_in">strcmp</span> (request, <span class="string">"END"</span>) == <span class="number">0</span>);</div><div class="line">        <span class="built_in">free</span> (request);</div><div class="line">        <span class="keyword">if</span> (finished) &#123;</div><div class="line">            <span class="built_in">printf</span> (<span class="string">"B received: %d\n"</span>, total);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        total++;</div><div class="line">    &#125;</div><div class="line">    zmq_close (worker);</div><div class="line">    zmq_term (context);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *context = zmq_init (<span class="number">1</span>);</div><div class="line">    <span class="keyword">void</span> *client = zmq_socket (context, ZMQ_ROUTER);</div><div class="line">    zmq_bind (client, <span class="string">"ipc://routing.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">pthread_t</span> worker;</div><div class="line">    pthread_create (&amp;worker, <span class="literal">NULL</span>, worker_task_a, <span class="literal">NULL</span>);</div><div class="line">    pthread_create (&amp;worker, <span class="literal">NULL</span>, worker_task_b, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 等待线程连接至套接字，否则我们发送的消息将不能被正确路由</span></div><div class="line">    sleep (<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 发送10个任务，给A两倍多的量</span></div><div class="line">    <span class="keyword">int</span> task_nbr;</div><div class="line">    srandom ((<span class="keyword">unsigned</span>) time (<span class="literal">NULL</span>));</div><div class="line">    <span class="keyword">for</span> (task_nbr = <span class="number">0</span>; task_nbr &lt; <span class="number">10</span>; task_nbr++) &#123;</div><div class="line">        <span class="comment">// 发送消息的两个部分：第一部分是目标地址</span></div><div class="line">        <span class="keyword">if</span> (randof (<span class="number">3</span>) &gt; <span class="number">0</span>)</div><div class="line">            s_sendmore (client, <span class="string">"A"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            s_sendmore (client, <span class="string">"B"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 然后是任务</span></div><div class="line">        s_send (client, <span class="string">"This is the workload"</span>);</div><div class="line">    &#125;</div><div class="line">    s_sendmore (client, <span class="string">"A"</span>);</div><div class="line">    s_send (client, <span class="string">"END"</span>);</div><div class="line"></div><div class="line">    s_sendmore (client, <span class="string">"B"</span>);</div><div class="line">    s_send (client, <span class="string">"END"</span>);</div><div class="line"></div><div class="line">    zmq_close (client);</div><div class="line">    zmq_term (context);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对上述代码的两点说明：</p>
<ul>
<li>ROUTER并不知道DEALER何时会准备好，我们可以用信号机制来解决，但为了不让这个例子太过复杂，我们就用sleep(1)的方式来处理。如果没有这句话，那ROUTER一开始发出的消息将无法被路由，ØMQ会丢弃这些消息。</li>
<li>需要注意的是，除了ROUTER会丢弃无法路由的消息外，PUB套接字当没有SUB连接它时也会丢弃发送出去的消息。其他套接字则会将无法发送的消息存储起来，直到有节点来处理它们。</li>
</ul>
<p>在将消息路由给DEALER时，我们手工建立了这样一个信封：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          +-------------+</div><div class="line">Frame 1   | Address     |</div><div class="line">          +-------------+-------------------------+</div><div class="line">Frame 2   | Data                                  |</div><div class="line">          +---------------------------------------+</div><div class="line"></div><div class="line"></div><div class="line">     Figure # - Routing envelope for dealer</div></pre></td></tr></table></figure>
<p>ROUTER套接字会移除第一帧，只将第二帧的内容传递给相应的DEALER。当DEALER发送消息给ROUTER时，只会发送一帧，ROUTER会在外层包裹一个信封（添加第一帧），返回给我们。</p>
<p>如果你定义了一个非法的信封地址，ROUTER会直接丢弃该消息，不作任何提示。对于这一点我们也无能为力，因为出现这种情况只有两种可能，一是要送达的目标节点不复存在了，或是程序中错误地指定了目标地址。如何才能知道消息会被正确地路由？唯一的方法是让路由目标发送一些反馈消息给我们。后面几章会讲述这一点。</p>
<p>DEALER的工作方式就像是PUSH和PULL的结合。但是，我们不能用PULL或PUSH去构建请求-应答模式。</p>
<h3 id="最近最少使用算法路由（LRU模式）"><a href="#最近最少使用算法路由（LRU模式）" class="headerlink" title="最近最少使用算法路由（LRU模式）"></a>最近最少使用算法路由（LRU模式）</h3><p>我们之前讲过REQ套接字永远是对话的发起方，然后等待对方回答。这一特性可以让我们能够保持多个REQ套接字等待调配。换句话说，REQ套接字会告诉我们它已经准备好了。</p>
<p>你可以将ROUTER和多个REQ相连，请求-应答的过程如下：</p>
<ul>
<li>REQ发送消息给ROUTER</li>
<li>ROUTER返回消息给REQ</li>
<li>REQ发送消息给ROUTER</li>
<li>ROUTER返回消息给REQ</li>
<li>…</li>
</ul>
<p>和DEALER相同，REQ只能和一个ROUTER连接，除非你想做类似多路冗余路由这样的事（我甚至不想在这里解释），其复杂度会超过你的想象并迫使你放弃的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">       +-------------+</div><div class="line">       |             |</div><div class="line">       |   Client    |   Send to &quot;A&quot; or &quot;B&quot;</div><div class="line">       |             |</div><div class="line">       +-------------+</div><div class="line">       |   ROUTER    |</div><div class="line">       \-------------/</div><div class="line">              ^</div><div class="line">              |  (1) Mama says Hi</div><div class="line">              |</div><div class="line">      +-------+-------+</div><div class="line">      |               |</div><div class="line">      |               |   (2) Router gives laundry</div><div class="line">      v               v</div><div class="line">/-----------\   /-----------\</div><div class="line">|    REQ    |   |    REQ    |</div><div class="line">|    &quot;A&quot;    |   |    &quot;B&quot;    |</div><div class="line">+-----------+   +-----------+</div><div class="line">|           |   |           |</div><div class="line">|  Worker   |   |   Worker  |</div><div class="line">|           |   |           |</div><div class="line">+-----------+   +-----------+</div><div class="line"></div><div class="line"></div><div class="line">Figure # - Router to mama custom routing</div></pre></td></tr></table></figure>
<p>ROUTER-REQ模式可以用来做什么？最常用的做法就是最近最少使用算法（LRU）路由了，ROUTER发出的请求会让等待最久的REQ来处理。请看示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 自定义ROUTER-REQ路由</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zhelpers.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_WORKERS 10</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">worker_task</span><span class="params">(<span class="keyword">void</span> *args)</span> &#123;</div><div class="line">    <span class="keyword">void</span> *context = zmq_init(<span class="number">1</span>);</div><div class="line">    <span class="keyword">void</span> *worker = zmq_socket(context, ZMQ_REQ);</div><div class="line"></div><div class="line">    <span class="comment">// s_set_id()函数会根据套接字生成一个可打印的字符串，</span></div><div class="line">    <span class="comment">// 并以此作为该套接字的标识。</span></div><div class="line">    s_set_id(worker);</div><div class="line">    zmq_connect(worker, <span class="string">"ipc://routing.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">	    <span class="comment">// 告诉ROUTER我已经准备好了</span></div><div class="line">        s_send(worker, <span class="string">"ready"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 从ROUTER中获取工作，直到收到结束的信息</span></div><div class="line">        <span class="keyword">char</span> *workload = s_recv(worker);</div><div class="line">        <span class="keyword">int</span> finished = (<span class="built_in">strcmp</span>(workload, <span class="string">"END"</span>) == <span class="number">0</span>);</div><div class="line">        <span class="built_in">free</span>(workload);</div><div class="line">        <span class="keyword">if</span> (finished) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Processed: %d tasks\n"</span>, total);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        total++;</div><div class="line"></div><div class="line">        <span class="comment">// 随机等待一段时间</span></div><div class="line">        s_sleep(randof(<span class="number">1000</span>) + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    zmq_close(worker);</div><div class="line">    zmq_term(context);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *context = zmq_init(<span class="number">1</span>);</div><div class="line">    <span class="keyword">void</span> *client = zmq_socket(context, ZMQ_ROUTER);</div><div class="line">    zmq_bind(client, <span class="string">"ipc://routing.ipc"</span>);</div><div class="line">    srandom((<span class="keyword">unsigned</span>) time(<span class="literal">NULL</span>));</div><div class="line"></div><div class="line">    <span class="keyword">int</span> worker_nbr;</div><div class="line">    <span class="keyword">for</span> (worker_nbr = <span class="number">0</span>; worker_nbr &lt; NBR_WORKERS; worker_nbr++) &#123;</div><div class="line">        <span class="keyword">pthread_t</span> worker;</div><div class="line">        pthread_create(&amp;worker, <span class="literal">NULL</span>, worker_task, <span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> task_nbr;</div><div class="line">    <span class="keyword">for</span> (task_nbr = <span class="number">0</span>; task_nbr &lt; NBR_WORKERS * <span class="number">10</span>; task_nbr++) &#123;</div><div class="line">        <span class="comment">// 最近最少使用的worker就在消息队列中</span></div><div class="line">        <span class="keyword">char</span> *address = s_recv(client);</div><div class="line">        <span class="keyword">char</span> *empty = s_recv(client);</div><div class="line">        <span class="built_in">free</span>(empty);</div><div class="line">        <span class="keyword">char</span> *ready = s_recv(client);</div><div class="line">        <span class="built_in">free</span>(ready);</div><div class="line"></div><div class="line">        s_sendmore(client, address);</div><div class="line">        s_sendmore(client, <span class="string">""</span>);</div><div class="line">        s_send(client, <span class="string">"This is the workload"</span>);</div><div class="line">        <span class="built_in">free</span>(address);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通知所有REQ套接字结束工作</span></div><div class="line">    <span class="keyword">for</span> (worker_nbr = <span class="number">0</span>; worker_nbr &lt; NBR_WORKERS; worker_nbr++) &#123;</div><div class="line">        <span class="keyword">char</span> *address = s_recv(client);</div><div class="line">        <span class="keyword">char</span> *empty = s_recv(client);</div><div class="line">        <span class="built_in">free</span>(empty);</div><div class="line">        <span class="keyword">char</span> *ready = s_recv(client);</div><div class="line">        <span class="built_in">free</span>(ready);</div><div class="line"></div><div class="line">        s_sendmore(client, address);</div><div class="line">        s_sendmore(client, <span class="string">""</span>);</div><div class="line">        s_send(client, <span class="string">"END"</span>);</div><div class="line">        <span class="built_in">free</span>(address);</div><div class="line">    &#125;</div><div class="line">    zmq_close(client);</div><div class="line">    zmq_term(context);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个示例中，实现LRU算法并没有用到特别的数据结构，因为ØMQ的消息队列机制已经提供了等价的实现。一个更为实际的LRU算法应该将已准备好的worker收集起来，保存在一个队列中进行分配。以后我们会讲到这个例子。</p>
<p>程序的运行结果会将每个worker的执行次数打印出来。由于REQ套接字会随机等待一段时间，而我们也没有做负载均衡，所以我们希望看到的是每个worker执行相近的工作量。这也是程序执行的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Processed: 8 tasks</div><div class="line">Processed: 8 tasks</div><div class="line">Processed: 11 tasks</div><div class="line">Processed: 7 tasks</div><div class="line">Processed: 9 tasks</div><div class="line">Processed: 11 tasks</div><div class="line">Processed: 14 tasks</div><div class="line">Processed: 11 tasks</div><div class="line">Processed: 11 tasks</div><div class="line">Processed: 10 tasks</div></pre></td></tr></table></figure>
<p>关于以上代码的几点说明：</p>
<ul>
<li><p>我们不需要像前一个例子一样等待一段时间，因为REQ套接字会明确告诉ROUTER它已经准备好了。</p>
</li>
<li><p>我们使用了zhelpers.h提供的s_set_id()函数来为套接字生成一个可打印的字符串标识，这是为了让例子简单一些。在现实环境中，REQ套接字都是匿名的，你需要直接调用zmq_recv()和zmq_send()来处理消息，因为s_recv()和s_send()只能处理字符串标识的套接字。</p>
</li>
<li><p>更糟的是，我们使用了随机的标识，不要在现实环境中使用随机标识的持久套接字，这样做会将节点消耗殆尽。</p>
</li>
<li><p>如果你只是将上面的代码拷贝过来，没有充分理解，那你就像是看到蜘蛛人从屋顶上飞下来，你也照着做了，后果自负吧。</p>
</li>
</ul>
<p>在将消息路由给REQ套接字时，需要注意一定的格式，即地址-空帧-消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          +-------------+</div><div class="line">Frame 1   | Address     |</div><div class="line">          +---+---------+</div><div class="line">Frame 2   |   |   &lt;------ Empty message part</div><div class="line">          +---+-----------------------------------+</div><div class="line">Frame 3   | Data                                  |</div><div class="line">          +---------------------------------------+</div><div class="line"></div><div class="line"></div><div class="line">    Figure # - Routing envelope for mama (REQ)</div></pre></td></tr></table></figure>
<h3 id="使用地址进行路由"><a href="#使用地址进行路由" class="headerlink" title="使用地址进行路由"></a>使用地址进行路由</h3><p>在经典的请求-应答模式中，ROUTER一般不会和REP套接字通信，而是由DEALER去和REP通信。DEALER会将消息随机分发给多个REP，并获得结果。ROUTER更适合和REQ套接字通信。</p>
<p>我们应该记住，ØMQ的经典模型往往是运行得最好的，毕竟人走得多的路往往是条好路，如果不按常理出牌，那很有可能会跌入无敌深潭。下面我们就将ROUTER和REP进行连接，看看会发生什么。</p>
<p>REP套接字有两个特点：</p>
<ul>
<li>它需要完成完整的请求-应答周期；</li>
<li>它可以接受任意大小的信封，并能完整地返回该信封。</li>
</ul>
<p>在一般的请求-应答模式中，REP是匿名的，可以随时替换。因为我们这里在将自定义路由，就要做到将一条消息发送给REP A，而不是REP B。这样才能保证网络的一端是你，另一端是特定的REP。</p>
<p>ØMQ的核心理念之一是周边的节点应该尽可能的智能，且数量众多，而中间件则是固定和简单的。这就意味着周边节点可以向其他特定的节点发送消息，比如可以连接到一个特定的REP。这里我们先不讨论如何在多个节点之间进行路由，只看最后一步中ROUTER如何和特定的REP通信的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">       +-------------+</div><div class="line">       |             |</div><div class="line">       |   Client    |   Send to &quot;A&quot; or &quot;B&quot;</div><div class="line">       |             |</div><div class="line">       +-------------+</div><div class="line">       |   ROUTER    |</div><div class="line">       \-------------/</div><div class="line">              ^</div><div class="line">              |</div><div class="line">              |</div><div class="line">      +-------+-------+</div><div class="line">      |               |</div><div class="line">      |               |</div><div class="line">      v               v</div><div class="line">/-----------\   /-----------\</div><div class="line">|    REP    |   |    REP    |</div><div class="line">|    &quot;A&quot;    |   |    &quot;B&quot;    |</div><div class="line">+-----------+   +-----------+</div><div class="line">|           |   |           |</div><div class="line">|  Worker   |   |   Worker  |</div><div class="line">|           |   |           |</div><div class="line">+-----------+   +-----------+</div><div class="line"></div><div class="line"></div><div class="line"> Figure # - Router to papa custom routing</div></pre></td></tr></table></figure>
<p>这张图描述了以下事件：</p>
<ul>
<li>client有一条消息，将来会通过另一个ROUTER将该消息发送回去。这条信息包含了两个地址、一个空帧、以及消息内容；</li>
<li>client将该条消息发送给了ROUTER，并指定了REP的地址；</li>
<li>ROUTER将该地址移去，并以此决定其下哪个REP可以获得该消息；</li>
<li>REP收到该条包含地址、空帧、以及内容的消息；</li>
<li>REP将空帧之前的所有内容移去，交给worker去处理消息；</li>
<li>worker处理完成后将回复交给REP；</li>
<li>REP将之前保存好的信封包裹住该条回复，并发送给ROUTER；</li>
<li>ROUTER在该条回复上又添加了一个注明REP的地址的帧。</li>
</ul>
<p>这个过程看起来很复杂，但还是有必要取了解清楚的。只要记住，REP套接字会原封不动地将信封返回回去。</p>
<p><strong>rtpapa.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  自定义ROUTER-REP路由</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zhelpers.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">//  这里使用一个进程来强调事件发生的顺序性</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *context = zmq_init (<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">void</span> *client = zmq_socket (context, ZMQ_ROUTER);</div><div class="line">    zmq_bind (client, <span class="string">"ipc://routing.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">void</span> *worker = zmq_socket (context, ZMQ_REP);</div><div class="line">    zmq_setsockopt (worker, ZMQ_IDENTITY, <span class="string">"A"</span>, <span class="number">1</span>);</div><div class="line">    zmq_connect (worker, <span class="string">"ipc://routing.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  等待worker连接</span></div><div class="line">    sleep (<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  发送REP的标识、地址、空帧、以及消息内容</span></div><div class="line">    s_sendmore (client, <span class="string">"A"</span>);</div><div class="line">    s_sendmore (client, <span class="string">"address 3"</span>);</div><div class="line">    s_sendmore (client, <span class="string">"address 2"</span>);</div><div class="line">    s_sendmore (client, <span class="string">"address 1"</span>);</div><div class="line">    s_sendmore (client, <span class="string">""</span>);</div><div class="line">    s_send     (client, <span class="string">"This is the workload"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  worker只会得到消息内容</span></div><div class="line">    s_dump (worker);</div><div class="line"></div><div class="line">    <span class="comment">//  worker不需要处理信封</span></div><div class="line">    s_send (worker, <span class="string">"This is the reply"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  看看ROUTER里收到了什么</span></div><div class="line">    s_dump (client);</div><div class="line"></div><div class="line">    zmq_close (client);</div><div class="line">    zmq_close (worker);</div><div class="line">    zmq_term (context);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">----------------------------------------</div><div class="line">[020] This is the workload</div><div class="line">----------------------------------------</div><div class="line">[001] A</div><div class="line">[009] address 3</div><div class="line">[009] address 2</div><div class="line">[009] address 1</div><div class="line">[000]</div><div class="line">[017] This is the reply</div></pre></td></tr></table></figure>
<p>关于以上代码的几点说明：</p>
<ul>
<li><p>在现实环境中，ROUTER和REP套接字处于不同的节点。本例没有启用多进程，为的是让事件的发生顺序更为清楚。</p>
</li>
<li><p>zmq_connect()并不是瞬间完成的，REP和ROUTER连接的时候是会花费一些时间的。在现实环境中，ROUTER无从得知REP是否已经连接成功了，除非得到REP的某些回应。本例中使用sleep(1)来处理这一问题，如果不这样做，那REP将无法获得消息（自己尝试一下吧）。</p>
</li>
<li><p>我们使用REP的套接字标识来进行路由，如果你不信，可以将消息发送给B，看看A能不能收到。</p>
</li>
<li><p>本例中的s_dump()等函数来自于zhelpers.h文件，可以看到在进行套接字连接时代码都是一样的，所以我们才能在ØMQ API的基础上搭建上层的API。等今后我们讨论到复杂应用程序的时候再详细说明。</p>
</li>
</ul>
<p>要将消息路由给REP，我们需要创建它能辨别的信封：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          +-------------+</div><div class="line">Frame 1   | Address     |  &lt;--- Zero or more of these</div><div class="line">          +---+---------+</div><div class="line">Frame 2   |   |   &lt;------ Exactly one empty message part</div><div class="line">          +---+-----------------------------------+</div><div class="line">Frame 3   | Data                                  |</div><div class="line">          +---------------------------------------+</div><div class="line"></div><div class="line"></div><div class="line">     Figure # - Routing envelope for papa aka REP</div></pre></td></tr></table></figure>
<h3 id="请求-应答模式下的消息代理"><a href="#请求-应答模式下的消息代理" class="headerlink" title="请求-应答模式下的消息代理"></a>请求-应答模式下的消息代理</h3><p>这一节我们将对如何使用ØMQ消息信封做一个回顾，并尝试编写一个通用的消息代理装置。我们会建立一个队列装置来连接多个client和worker，装置的路由算法可以由我们自己决定。这里我们选择最近最少使用算法，因为这和负载均衡一样比较实用。</p>
<p>首先让我们回顾一下经典的请求-应答模型，尝试用它建立一个不断增长的巨型服务网络。最基本的请求-应答模型是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">            +--------+</div><div class="line">            | Client |</div><div class="line">            +--------+</div><div class="line">            |  REQ   |</div><div class="line">            +---+----+</div><div class="line">                |</div><div class="line">                |</div><div class="line">    +-----------+-----------+</div><div class="line">    |           |           |</div><div class="line">    |           |           |</div><div class="line">+---+----+  +---+----+  +---+----+</div><div class="line">|  REP   |  |  REP   |  |  REP   |</div><div class="line">+--------+  +--------+  +--------+</div><div class="line">| Worker |  | Worker |  | Worker |</div><div class="line">+--------+  +--------+  +--------+</div><div class="line"></div><div class="line"></div><div class="line">  Figure # - Basic request-reply</div></pre></td></tr></table></figure>
<p>这个模型支持多个REP套接字，但如果我们想支持多个REQ套接字，就需要增加一个中间件，它通常是ROUTER和DEALER的结合体，简单将两个套接字之间的信息进行搬运，因此可以用现成的ZMQ_QUEUE装置来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">+--------+  +--------+  +--------+</div><div class="line">| Client |  | Client |  | Client |</div><div class="line">+--------+  +--------+  +--------+</div><div class="line">|  REQ   |  |  REQ   |  |  REQ   |</div><div class="line">+---+----+  +---+----+  +---+----+</div><div class="line">    |           |           |</div><div class="line">    +-----------+-----------+</div><div class="line">                |</div><div class="line">            +---+----+</div><div class="line">            | ROUTER |</div><div class="line">            +--------+</div><div class="line">            | Device |</div><div class="line">            +--------+</div><div class="line">            | DEALER |</div><div class="line">            +---+----+</div><div class="line">                |</div><div class="line">    +-----------+-----------+</div><div class="line">    |           |           |</div><div class="line">+---+----+  +---+----+  +---+----+</div><div class="line">|  REP   |  |  REP   |  |  REP   |</div><div class="line">+--------+  +--------+  +--------+</div><div class="line">| Worker |  | Worker |  | Worker |</div><div class="line">+--------+  +--------+  +--------+</div><div class="line"></div><div class="line"></div><div class="line">Figure # - Stretched request-reply</div></pre></td></tr></table></figure>
<p>这种结构的关键在于，ROUTER会将消息来自哪个REQ记录下来，生成一个信封。DEALER和REP套接字在传输消息的过程中不会丢弃或更改信封的内容，这样当消息返回给ROUTER时，它就知道应该发送给哪个REQ了。这个模型中的REP套接字是匿名的，并没有特定的地址，所以只能提供同一种服务。</p>
<p>上述结构中，对REP的路由我们使用了DEADER自带的负载均衡算法。但是，我们想用LRU算法来进行路由，这就要用到ROUTER-REP模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">    +--------+  +--------+  +--------+</div><div class="line">    | Client |  | Client |  | Client |</div><div class="line">    +--------+  +--------+  +--------+</div><div class="line">    |  REQ   |  |  REQ   |  |  REQ   |</div><div class="line">    +---+----+  +---+----+  +---+----+</div><div class="line">        |           |           |</div><div class="line">        +-----------+-----------+</div><div class="line">                    |</div><div class="line">                +---+----+</div><div class="line">                | ROUTER |  Frontend</div><div class="line">                +--------+</div><div class="line">                | Device |  LRU queue</div><div class="line">                +--------+</div><div class="line">                | ROUTER |  Backend</div><div class="line">                +---+----+</div><div class="line">                    |</div><div class="line">        +-----------+-----------+</div><div class="line">        |           |           |</div><div class="line">    +---+----+  +---+----+  +---+----+</div><div class="line">    |  REQ   |  |  REQ   |  |  REQ   |</div><div class="line">    +--------+  +--------+  +--------+</div><div class="line">    | Worker |  | Worker |  | Worker |</div><div class="line">    +--------+  +--------+  +--------+</div><div class="line"></div><div class="line"></div><div class="line">Figure # - Stretched request-reply with LRU</div></pre></td></tr></table></figure>
<p>这个ROUTER-ROUTER的LRU队列不能简单地在两个套接字间搬运消息，以下代码会比较复杂，不过在请求-应答模式中复用性很高。</p>
<p><strong>lruqueue.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  使用LRU算法的装置</span></div><div class="line"><span class="comment">//  client和worker处于不同的线程中</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"zhelpers.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_CLIENTS 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_WORKERS 3</span></div><div class="line"></div><div class="line"><span class="comment">//  出队操作，使用一个可存储任何类型的数组实现</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEQUEUE(q) memmove (&amp;(q)[0], &amp;(q)[1], sizeof (q) - sizeof (q [0]))</span></div><div class="line"></div><div class="line"><span class="comment">//  使用REQ套接字实现基本的请求-应答模式</span></div><div class="line"><span class="comment">//  由于s_send()和s_recv()不能处理0MQ的二进制套接字标识，</span></div><div class="line"><span class="comment">//  所以这里会生成一个可打印的字符串标识。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">client_task</span> <span class="params">(<span class="keyword">void</span> *args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *context = zmq_init (<span class="number">1</span>);</div><div class="line">    <span class="keyword">void</span> *client = zmq_socket (context, ZMQ_REQ);</div><div class="line">    s_set_id (client);          <span class="comment">//  设置可打印的标识</span></div><div class="line">    zmq_connect (client, <span class="string">"ipc://frontend.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  发送请求并获取应答信息</span></div><div class="line">    s_send (client, <span class="string">"HELLO"</span>);</div><div class="line">    <span class="keyword">char</span> *reply = s_recv (client);</div><div class="line">    <span class="built_in">printf</span> (<span class="string">"Client: %s\n"</span>, reply);</div><div class="line">    <span class="built_in">free</span> (reply);</div><div class="line">    zmq_close (client);</div><div class="line">    zmq_term (context);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  worker使用REQ套接字实现LRU算法</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">worker_task</span> <span class="params">(<span class="keyword">void</span> *args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *context = zmq_init (<span class="number">1</span>);</div><div class="line">    <span class="keyword">void</span> *worker = zmq_socket (context, ZMQ_REQ);</div><div class="line">    s_set_id (worker);          <span class="comment">//  设置可打印的标识</span></div><div class="line">    zmq_connect (worker, <span class="string">"ipc://backend.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  告诉代理worker已经准备好</span></div><div class="line">    s_send (worker, <span class="string">"READY"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//  将消息中空帧之前的所有内容（信封）保存起来，</span></div><div class="line">        <span class="comment">//  本例中空帧之前只有一帧，但可以有更多。</span></div><div class="line">        <span class="keyword">char</span> *address = s_recv (worker);</div><div class="line">        <span class="keyword">char</span> *empty = s_recv (worker);</div><div class="line">        assert (*empty == <span class="number">0</span>);</div><div class="line">        <span class="built_in">free</span> (empty);</div><div class="line"></div><div class="line">        <span class="comment">//  获取请求，并发送回应</span></div><div class="line">        <span class="keyword">char</span> *request = s_recv (worker);</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"Worker: %s\n"</span>, request);</div><div class="line">        <span class="built_in">free</span> (request);</div><div class="line"></div><div class="line">        s_sendmore (worker, address);</div><div class="line">        s_sendmore (worker, <span class="string">""</span>);</div><div class="line">        s_send     (worker, <span class="string">"OK"</span>);</div><div class="line">        <span class="built_in">free</span> (address);</div><div class="line">    &#125;</div><div class="line">    zmq_close (worker);</div><div class="line">    zmq_term (context);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//  准备0MQ上下文和套接字</span></div><div class="line">    <span class="keyword">void</span> *context = zmq_init (<span class="number">1</span>);</div><div class="line">    <span class="keyword">void</span> *frontend = zmq_socket (context, ZMQ_ROUTER);</div><div class="line">    <span class="keyword">void</span> *backend  = zmq_socket (context, ZMQ_ROUTER);</div><div class="line">    zmq_bind (frontend, <span class="string">"ipc://frontend.ipc"</span>);</div><div class="line">    zmq_bind (backend,  <span class="string">"ipc://backend.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> client_nbr;</div><div class="line">    <span class="keyword">for</span> (client_nbr = <span class="number">0</span>; client_nbr &lt; NBR_CLIENTS; client_nbr++) &#123;</div><div class="line">        <span class="keyword">pthread_t</span> client;</div><div class="line">        pthread_create (&amp;client, <span class="literal">NULL</span>, client_task, <span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> worker_nbr;</div><div class="line">    <span class="keyword">for</span> (worker_nbr = <span class="number">0</span>; worker_nbr &lt; NBR_WORKERS; worker_nbr++) &#123;</div><div class="line">        <span class="keyword">pthread_t</span> worker;</div><div class="line">        pthread_create (&amp;worker, <span class="literal">NULL</span>, worker_task, <span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//  LRU逻辑</span></div><div class="line">    <span class="comment">//  - 一直从backend中获取消息；当有超过一个worker空闲时才从frontend获取消息。</span></div><div class="line">    <span class="comment">//  - 当woker回应时，会将该worker标记为已准备好，并转发woker的回应给client</span></div><div class="line">    <span class="comment">//  - 如果client发送了请求，就将该请求转发给下一个worker</span></div><div class="line"></div><div class="line">    <span class="comment">//  存放可用worker的队列</span></div><div class="line">    <span class="keyword">int</span> available_workers = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> *worker_queue [<span class="number">10</span>];</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">zmq_pollitem_t</span> items [] = &#123;</div><div class="line">            &#123; backend,  <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</div><div class="line">            &#123; frontend, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</div><div class="line">        &#125;;</div><div class="line">        zmq_poll (items, available_workers? <span class="number">2</span>: <span class="number">1</span>, <span class="number">-1</span>);</div><div class="line"></div><div class="line">        <span class="comment">//  处理backend中worker的队列</span></div><div class="line">        <span class="keyword">if</span> (items [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            <span class="comment">//  将worker的地址入队</span></div><div class="line">            <span class="keyword">char</span> *worker_addr = s_recv (backend);</div><div class="line">            assert (available_workers &lt; NBR_WORKERS);</div><div class="line">            worker_queue [available_workers++] = worker_addr;</div><div class="line"></div><div class="line">            <span class="comment">//  跳过空帧</span></div><div class="line"></div><div class="line">            <span class="keyword">char</span> *empty = s_recv (backend);</div><div class="line">            assert (empty [<span class="number">0</span>] == <span class="number">0</span>);</div><div class="line">            <span class="built_in">free</span> (empty);</div><div class="line"></div><div class="line">            <span class="comment">// 第三帧是“READY”或是一个client的地址</span></div><div class="line">            <span class="keyword">char</span> *client_addr = s_recv (backend);</div><div class="line"></div><div class="line">            <span class="comment">//  如果是一个应答消息，则转发给client</span></div><div class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span> (client_addr, <span class="string">"READY"</span>) != <span class="number">0</span>) &#123;</div><div class="line">                empty = s_recv (backend);</div><div class="line">                assert (empty [<span class="number">0</span>] == <span class="number">0</span>);</div><div class="line">                <span class="built_in">free</span> (empty);</div><div class="line">                <span class="keyword">char</span> *reply = s_recv (backend);</div><div class="line">                s_sendmore (frontend, client_addr);</div><div class="line">                s_sendmore (frontend, <span class="string">""</span>);</div><div class="line">                s_send     (frontend, reply);</div><div class="line">                <span class="built_in">free</span> (reply);</div><div class="line">                <span class="keyword">if</span> (--client_nbr == <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;      <span class="comment">//  处理N条消息后退出</span></div><div class="line">            &#125;</div><div class="line">            <span class="built_in">free</span> (client_addr);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (items [<span class="number">1</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            <span class="comment">//  获取下一个client的请求，交给空闲的worker处理</span></div><div class="line">            <span class="comment">//  client请求的消息格式是：[client地址][空帧][请求内容]</span></div><div class="line">            <span class="keyword">char</span> *client_addr = s_recv (frontend);</div><div class="line">            <span class="keyword">char</span> *empty = s_recv (frontend);</div><div class="line">            assert (empty [<span class="number">0</span>] == <span class="number">0</span>);</div><div class="line">            <span class="built_in">free</span> (empty);</div><div class="line">            <span class="keyword">char</span> *request = s_recv (frontend);</div><div class="line"></div><div class="line">            s_sendmore (backend, worker_queue [<span class="number">0</span>]);</div><div class="line">            s_sendmore (backend, <span class="string">""</span>);</div><div class="line">            s_sendmore (backend, client_addr);</div><div class="line">            s_sendmore (backend, <span class="string">""</span>);</div><div class="line">            s_send     (backend, request);</div><div class="line"></div><div class="line">            <span class="built_in">free</span> (client_addr);</div><div class="line">            <span class="built_in">free</span> (request);</div><div class="line"></div><div class="line">            <span class="comment">//  将该worker的地址出队</span></div><div class="line">            <span class="built_in">free</span> (worker_queue [<span class="number">0</span>]);</div><div class="line">            DEQUEUE (worker_queue);</div><div class="line">            available_workers--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    zmq_close (frontend);</div><div class="line">    zmq_close (backend);</div><div class="line">    zmq_term (context);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段程序有两个关键点：1、各个套接字是如何处理信封的；2、LRU算法。我们先来看信封的格式。</p>
<p>我们知道REQ套接字在发送消息时会向头部添加一个空帧，接收时又会自动移除。我们要做的就是在传输消息时满足REQ的要求，处理好空帧。另外还要注意，ROUTER会在所有收到的消息前添加消息来源的地址。</p>
<p>现在我们就将完整的请求-应答流程走一遍，我们将client套接字的标识设为“CLIENT”，worker的设为“WORKER”。以下是client发送的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          +---+-------+</div><div class="line">Frame 1   | 5 | HELLO |       Data part</div><div class="line">          +---+-------+</div><div class="line"></div><div class="line"></div><div class="line"> Figure # - Message that client sends</div></pre></td></tr></table></figure>
<p>代理从ROUTER中获取到的消息格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          +---+--------+</div><div class="line">Frame 1   | 6 | CLIENT |    Identity of client</div><div class="line">          +---+--------+</div><div class="line">Frame 2   | 0 |               Empty message part</div><div class="line">          +---+-------+</div><div class="line">Frame 3   | 5 | HELLO |       Data part</div><div class="line">          +---+-------+</div><div class="line"></div><div class="line"></div><div class="line">    Figure # - Message coming in on frontend</div></pre></td></tr></table></figure>
<p>代理会从LRU队列中获取一个空闲woker的地址，作为信封附加在消息之上，传送给ROUTER。注意要添加一个空帧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">          +---+--------+</div><div class="line">Frame 1   | 6 | WORKER |     Identity of worker</div><div class="line">          +---+--------+</div><div class="line">Frame 2   | 0 |               Empty message part</div><div class="line">          +---+--------+</div><div class="line">Frame 3   | 6 | CLIENT |    Identity of client</div><div class="line">          +---+--------+</div><div class="line">Frame 4   | 0 |               Empty message part</div><div class="line">          +---+-------+</div><div class="line">Frame 5   | 5 | HELLO |       Data part</div><div class="line">          +---+-------+</div><div class="line"></div><div class="line"></div><div class="line">       Figure # - Message sent to backend</div></pre></td></tr></table></figure>
<p>REQ（worker）收到消息时，会将信封和空帧移去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          +---+--------+</div><div class="line">Frame 1   | 6 | CLIENT |    Identity of client</div><div class="line">          +---+--------+</div><div class="line">Frame 2   | 0 |               Empty message part</div><div class="line">          +---+-------+</div><div class="line">Frame 3   | 5 | HELLO |       Data part</div><div class="line">          +---+-------+</div><div class="line"></div><div class="line"></div><div class="line">     Figure # - Message delivered to worker</div></pre></td></tr></table></figure>
<p>可以看到，worker收到的消息和client端ROUTER收到的消息是一致的。worker需要将该消息中的信封保存起来，只对消息内容做操作。</p>
<p>在返回的过程中：</p>
<ul>
<li>worker通过REQ传输给device消息[client地址][空帧][应答内容]；</li>
<li>device从worker端的ROUTER中获取到[worker地址][空帧][client地址][空帧][应答内容]；</li>
<li>device将worker地址保存起来，并发送[client地址][空帧][应答内容]给client端的ROUTER；</li>
<li>client从REQ中获得到[应答内容]。</li>
</ul>
<p>然后再看看LRU算法，它要求client和worker都使用REQ套接字，并正确的存储和返回消息信封，具体如下：</p>
<ul>
<li><p>创建一组poll，不断地从backend（worker端的ROUTER）获取消息；只有当有空闲的worker时才从frontend（client端的ROUTER）获取消息；</p>
</li>
<li><p>循环执行poll</p>
</li>
<li><p>如果backend有消息，只有两种情况：1）READY消息（该worker已准备好，等待分配）；2）应答消息（需要转发给client）。两种情况下我们都会保存worker的地址，放入LRU队列中，如果有应答内容，则转发给相应的client。</p>
</li>
<li><p>如果frontend有消息，我们从LRU队列中取出下一个worker，将该请求发送给它。这就需要发送[worker地址][空帧][client地址][空帧][请求内容]到worker端的ROUTER。</p>
</li>
</ul>
<p>我们可以对该算法进行扩展，如在worker启动时做一个自我测试，计算出自身的处理速度，并随READY消息发送给代理，这样代理在分配工作时就可以做相应的安排。</p>
<h3 id="OMQ上层API的封装"><a href="#OMQ上层API的封装" class="headerlink" title="ØMQ上层API的封装"></a>ØMQ上层API的封装</h3><p>使用ØMQ提供的API操作多段消息时是很麻烦的，如以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//  将消息中空帧之前的所有内容（信封）保存起来，</span></div><div class="line">    <span class="comment">//  本例中空帧之前只有一帧，但可以有更多。</span></div><div class="line">    <span class="keyword">char</span> *address = s_recv (worker);</div><div class="line">    <span class="keyword">char</span> *empty = s_recv (worker);</div><div class="line">    assert (*empty == <span class="number">0</span>);</div><div class="line">    <span class="built_in">free</span> (empty);</div><div class="line"></div><div class="line">    <span class="comment">//  获取请求，并发送回应</span></div><div class="line">    <span class="keyword">char</span> *request = s_recv (worker);</div><div class="line">    <span class="built_in">printf</span> (<span class="string">"Worker: %s\n"</span>, request);</div><div class="line">    <span class="built_in">free</span> (request);</div><div class="line">    s_sendmore (worker, address);</div><div class="line">    s_sendmore (worker, <span class="string">""</span>);</div><div class="line">    s_send     (worker, <span class="string">"OK"</span>);</div><div class="line">    <span class="built_in">free</span> (address);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码不满足重用的需求，因为它只能处理一个帧的信封。事实上，以上代码已经做了一些封装了，如果调用ØMQ底层的API的话，代码就会更加冗长：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//  将消息中空帧之前的所有内容（信封）保存起来，</span></div><div class="line">    <span class="comment">//  本例中空帧之前只有一帧，但可以有更多。</span></div><div class="line">    <span class="keyword">zmq_msg_t</span> address;</div><div class="line">    zmq_msg_init (&amp;address);</div><div class="line">    zmq_recv (worker, &amp;address, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">zmq_msg_t</span> empty;</div><div class="line">    zmq_msg_init (&amp;empty);</div><div class="line">    zmq_recv (worker, &amp;empty, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  获取请求，并发送回应</span></div><div class="line">    <span class="keyword">zmq_msg_t</span> payload;</div><div class="line">    zmq_msg_init (&amp;payload);</div><div class="line">    zmq_recv (worker, &amp;payload, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> char_nbr;</div><div class="line">    <span class="built_in">printf</span> (<span class="string">"Worker: "</span>);</div><div class="line">    <span class="keyword">for</span> (char_nbr = <span class="number">0</span>; char_nbr &lt; zmq_msg_size (&amp;payload); char_nbr++)</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"%c"</span>, *(<span class="keyword">char</span> *) (zmq_msg_data (&amp;payload) + char_nbr));</div><div class="line">    <span class="built_in">printf</span> (<span class="string">"\n"</span>);</div><div class="line"></div><div class="line">    zmq_msg_init_size (&amp;payload, <span class="number">2</span>);</div><div class="line">    <span class="built_in">memcpy</span> (zmq_msg_data (&amp;payload), <span class="string">"OK"</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line">    zmq_send (worker, &amp;address, ZMQ_SNDMORE);</div><div class="line">    zmq_close (&amp;address);</div><div class="line">    zmq_send (worker, &amp;empty, ZMQ_SNDMORE);</div><div class="line">    zmq_close (&amp;empty);</div><div class="line">    zmq_send (worker, &amp;payload, <span class="number">0</span>);</div><div class="line">    zmq_close (&amp;payload);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们理想中的API是可以一步接收和处理完整的消息，包括信封。ØMQ底层的API并不是为此而涉及的，但我们可以在它上层做进一步的封装，这也是学习ØMQ的过程中很重要的内容。</p>
<p>想要编写这样一个API还是很有难度的，因为我们要避免过于频繁地复制数据。此外，ØMQ用“消息”来定义多段消息和多段消息中的一部分，同时，消息又可以是字符串消息或者二进制消息，这也给编写API增加的难度。</p>
<p>解决方法之一是使用新的命名方式：字符串（s_send()和s_recv()中已经在用了）、帧（消息的一部分）、消息（一个或多个帧）。以下是用新的API重写的worker：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">zmsg_t</span> *zmsg = zmsg_recv (worker);</div><div class="line">    zframe_print (zmsg_last (zmsg), <span class="string">"Worker: "</span>);</div><div class="line">    zframe_reset (zmsg_last (zmsg), <span class="string">"OK"</span>, <span class="number">2</span>);</div><div class="line">    zmsg_send (&amp;zmsg, worker);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用4行代码代替22行代码是个不错的选择，而且更容易读懂。我们可以用这种理念继续编写其他的API，希望可以实现以下功能：</p>
<ul>
<li><p>自动处理套接字。每次都要手动关闭套接字是很麻烦的事，手动定义过期时间也不是太有必要，所以，如果能在关闭上下文时自动关闭套接字就太好了。</p>
</li>
<li><p>便捷的线程管理。基本上所有的ØMQ应用都会用到多线程，但POSIX的多线程接口用起来并不是太方便，所以也可以封装一下。</p>
</li>
<li><p>便捷的时钟管理。想要获取毫秒数、或是暂停运行几毫秒都不太方便，我们的API应该提供这个接口。</p>
</li>
<li><p>一个能够替代zmq_poll()的反应器。poll循环很简单，但比较笨拙，会造成重复代码：计算时间、处理套接字中的信息等。若有一个简单的反应器来处理套接字的读写以及时间的控制，将会很方便。</p>
</li>
<li><p>恰当地处理Ctrl-C按键。我么已经看到如何处理中断了，最好这一机制可以用到所有的程序里。</p>
</li>
</ul>
<p>我们可以用czmq来实现以上的需求。这个扩展很早就有了，提供了很多ØMQ的上层封装，甚至是数据结构（哈希、链表等）。</p>
<p>以下是用czmq重写的LRU代理：</p>
<p><strong>lruqueue2.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  LRU消息队列装置，使用czmq库实现</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"czmq.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_CLIENTS 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_WORKERS 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_READY   <span class="meta-string">"\001"</span>      <span class="comment">//  worker准备就绪的信息</span></span></div><div class="line"></div><div class="line"><span class="comment">//  使用REQ套接字实现基本的请求-应答模式</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">client_task</span> <span class="params">(<span class="keyword">void</span> *args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">void</span> *client = zsocket_new (ctx, ZMQ_REQ);</div><div class="line">    zsocket_connect (client, <span class="string">"ipc://frontend.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  发送请求并接收应答</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        zstr_send (client, <span class="string">"HELLO"</span>);</div><div class="line">        <span class="keyword">char</span> *reply = zstr_recv (client);</div><div class="line">        <span class="keyword">if</span> (!reply)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"Client: %s\n"</span>, reply);</div><div class="line">        <span class="built_in">free</span> (reply);</div><div class="line">        sleep (<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  worker使用REQ套接字，实现LRU路由</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">worker_task</span> <span class="params">(<span class="keyword">void</span> *args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">void</span> *worker = zsocket_new (ctx, ZMQ_REQ);</div><div class="line">    zsocket_connect (worker, <span class="string">"ipc://backend.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  告知代理worker已准备就绪</span></div><div class="line">    <span class="keyword">zframe_t</span> *frame = zframe_new (LRU_READY, <span class="number">1</span>);</div><div class="line">    zframe_send (&amp;frame, worker, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  接收消息并处理</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">zmsg_t</span> *msg = zmsg_recv (worker);</div><div class="line">        <span class="keyword">if</span> (!msg)</div><div class="line">            <span class="keyword">break</span>;              <span class="comment">//  终止</span></div><div class="line">        <span class="comment">//zframe_print (zmsg_last (msg), "Worker: ");</span></div><div class="line">        zframe_reset (zmsg_last (msg), <span class="string">"OK"</span>, <span class="number">2</span>);</div><div class="line">        zmsg_send (&amp;msg, worker);</div><div class="line">    &#125;</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">void</span> *frontend = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    <span class="keyword">void</span> *backend = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    zsocket_bind (frontend, <span class="string">"ipc://frontend.ipc"</span>);</div><div class="line">    zsocket_bind (backend, <span class="string">"ipc://backend.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> client_nbr;</div><div class="line">    <span class="keyword">for</span> (client_nbr = <span class="number">0</span>; client_nbr &lt; NBR_CLIENTS; client_nbr++)</div><div class="line">        zthread_new (ctx, client_task, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">int</span> worker_nbr;</div><div class="line">    <span class="keyword">for</span> (worker_nbr = <span class="number">0</span>; worker_nbr &lt; NBR_WORKERS; worker_nbr++)</div><div class="line">        zthread_new (ctx, worker_task, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  LRU逻辑</span></div><div class="line">    <span class="comment">//  - 一直从backend中获取消息；当有超过一个worker空闲时才从frontend获取消息。</span></div><div class="line">    <span class="comment">//  - 当woker回应时，会将该worker标记为已准备好，并转发woker的回应给client</span></div><div class="line">    <span class="comment">//  - 如果client发送了请求，就将该请求转发给下一个worker</span></div><div class="line"></div><div class="line">    <span class="comment">//  存放可用worker的队列</span></div><div class="line">    <span class="keyword">zlist_t</span> *workers = zlist_new ();</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//  初始化poll</span></div><div class="line">        <span class="keyword">zmq_pollitem_t</span> items [] = &#123;</div><div class="line">            &#123; backend,  <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</div><div class="line">            &#123; frontend, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//  当有可用的worker时，从frontend获取消息</span></div><div class="line">        <span class="keyword">int</span> rc = zmq_poll (items, zlist_size (workers)? <span class="number">2</span>: <span class="number">1</span>, <span class="number">-1</span>);</div><div class="line">        <span class="keyword">if</span> (rc == <span class="number">-1</span>)</div><div class="line">            <span class="keyword">break</span>;              <span class="comment">//  中断</span></div><div class="line"></div><div class="line">        <span class="comment">//  对backend发来的消息进行处理</span></div><div class="line">        <span class="keyword">if</span> (items [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            <span class="comment">//  使用worker的地址进行LRU路由</span></div><div class="line">            <span class="keyword">zmsg_t</span> *msg = zmsg_recv (backend);</div><div class="line">            <span class="keyword">if</span> (!msg)</div><div class="line">                <span class="keyword">break</span>;          <span class="comment">//  中断</span></div><div class="line">            <span class="keyword">zframe_t</span> *address = zmsg_unwrap (msg);</div><div class="line">            zlist_append (workers, address);</div><div class="line"></div><div class="line">            <span class="comment">//  如果不是READY消息，则转发给client</span></div><div class="line">            <span class="keyword">zframe_t</span> *frame = zmsg_first (msg);</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">memcmp</span> (zframe_data (frame), LRU_READY, <span class="number">1</span>) == <span class="number">0</span>)</div><div class="line">                zmsg_destroy (&amp;msg);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                zmsg_send (&amp;msg, frontend);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (items [<span class="number">1</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            <span class="comment">//  获取client发来的请求，转发给worker</span></div><div class="line">            <span class="keyword">zmsg_t</span> *msg = zmsg_recv (frontend);</div><div class="line">            <span class="keyword">if</span> (msg) &#123;</div><div class="line">                zmsg_wrap (msg, (<span class="keyword">zframe_t</span> *) zlist_pop (workers));</div><div class="line">                zmsg_send (&amp;msg, backend);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//  如果完成了，则进行一些清理工作</span></div><div class="line">    <span class="keyword">while</span> (zlist_size (workers)) &#123;</div><div class="line">        <span class="keyword">zframe_t</span> *frame = (<span class="keyword">zframe_t</span> *) zlist_pop (workers);</div><div class="line">        zframe_destroy (&amp;frame);</div><div class="line">    &#125;</div><div class="line">    zlist_destroy (&amp;workers);</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>czmq提供了一个简单的中断机制，当按下Ctrl-C时程序会终止ØMQ的运行，并返回-1，errno设置为EINTR。程序中断时，czmq的recv方法会返回NULL，所以你可以用下面的代码来作判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    zstr_send (client, <span class="string">"HELLO"</span>);</div><div class="line">    <span class="keyword">char</span> *reply = zstr_recv (client);</div><div class="line">    <span class="keyword">if</span> (!reply)</div><div class="line">        <span class="keyword">break</span>; <span class="comment">// 中断</span></div><div class="line">    <span class="built_in">printf</span> (<span class="string">"Client: %s\n"</span>, reply);</div><div class="line">    <span class="built_in">free</span> (reply);</div><div class="line">    sleep (<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果使用zmq_poll()函数，则可以这样判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int rc = zmq_poll (items, zlist_size (workers)? 2: 1, -1);</div><div class="line">if (rc == -1)</div><div class="line">    break; // 中断</div></pre></td></tr></table></figure>
<p>上例中还是使用了原生的zmq_poll()方法，也可以使用czmq提供的zloop反应器来实现，它可以做到：</p>
<ul>
<li>从任意套接字上获取消息，也就是说只要套接字有消息就可以触发函数；</li>
<li>停止读取套接字上的消息；</li>
<li>设置一个时钟，定时地读取消息。</li>
</ul>
<p>zloop内部当然是使用zmq_poll()实现的，但它可以做到动态地增减套接字上的监听器，重构poll池，并根据poll的超时时间来计算下一个时钟触发事件。</p>
<p>使用这种反应器模式后，我们的代码就更简洁了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">zloop_t</span> *reactor = zloop_new ();</div><div class="line">zloop_reader (reactor, self-&gt;backend, s_handle_backend, self);</div><div class="line">zloop_start (reactor);</div><div class="line">zloop_destroy (&amp;reactor);</div></pre></td></tr></table></figure>
<p>对消息的实际处理放在了程序的其他部分，并不是所有人都会喜欢这种风格，但zloop的确是将定时器和套接字的行为融合在了一起。在以后的例子中，我们会用zmq_poll()来处理简单的示例，使用zloop来处理复杂的。</p>
<p>下面我们用zloop来重写LRU队列装置</p>
<p><strong>lruqueue3.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  LRU队列装置，使用czmq及其反应器模式实现</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"czmq.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_CLIENTS 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_WORKERS 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_READY   <span class="meta-string">"\001"</span>      <span class="comment">//  woker已准备就绪的消息</span></span></div><div class="line"></div><div class="line"><span class="comment">//  使用REQ实现基本的请求-应答模式</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">client_task</span> <span class="params">(<span class="keyword">void</span> *args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">void</span> *client = zsocket_new (ctx, ZMQ_REQ);</div><div class="line">    zsocket_connect (client, <span class="string">"ipc://frontend.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  发送请求并接收应答</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        zstr_send (client, <span class="string">"HELLO"</span>);</div><div class="line">        <span class="keyword">char</span> *reply = zstr_recv (client);</div><div class="line">        <span class="keyword">if</span> (!reply)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"Client: %s\n"</span>, reply);</div><div class="line">        <span class="built_in">free</span> (reply);</div><div class="line">        sleep (<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  worker使用REQ套接字来实现路由</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">worker_task</span> <span class="params">(<span class="keyword">void</span> *arg_ptr)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">void</span> *worker = zsocket_new (ctx, ZMQ_REQ);</div><div class="line">    zsocket_connect (worker, <span class="string">"ipc://backend.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  告诉代理worker已经准备就绪</span></div><div class="line">    <span class="keyword">zframe_t</span> *frame = zframe_new (LRU_READY, <span class="number">1</span>);</div><div class="line">    zframe_send (&amp;frame, worker, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  获取消息并处理</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">zmsg_t</span> *msg = zmsg_recv (worker);</div><div class="line">        <span class="keyword">if</span> (!msg)</div><div class="line">            <span class="keyword">break</span>;              <span class="comment">//  中断</span></div><div class="line">        <span class="comment">//zframe_print (zmsg_last (msg), "Worker: ");</span></div><div class="line">        zframe_reset (zmsg_last (msg), <span class="string">"OK"</span>, <span class="number">2</span>);</div><div class="line">        zmsg_send (&amp;msg, worker);</div><div class="line">    &#125;</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  LRU队列处理器结构，将要传给反应器</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">void</span> *frontend;             <span class="comment">//  监听client</span></div><div class="line">    <span class="keyword">void</span> *backend;              <span class="comment">//  监听worker</span></div><div class="line">    <span class="keyword">zlist_t</span> *workers;           <span class="comment">//  可用的worker列表</span></div><div class="line">&#125; <span class="keyword">lruqueue_t</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//  处理frontend端的消息</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">s_handle_frontend</span> <span class="params">(<span class="keyword">zloop_t</span> *loop, <span class="keyword">void</span> *socket, <span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">lruqueue_t</span> *self = (<span class="keyword">lruqueue_t</span> *) arg;</div><div class="line">    <span class="keyword">zmsg_t</span> *msg = zmsg_recv (self-&gt;frontend);</div><div class="line">    <span class="keyword">if</span> (msg) &#123;</div><div class="line">        zmsg_wrap (msg, (<span class="keyword">zframe_t</span> *) zlist_pop (self-&gt;workers));</div><div class="line">        zmsg_send (&amp;msg, self-&gt;backend);</div><div class="line"></div><div class="line">        <span class="comment">//  如果没有可用的worker，则停止监听frontend</span></div><div class="line">        <span class="keyword">if</span> (zlist_size (self-&gt;workers) == <span class="number">0</span>)</div><div class="line">            zloop_cancel (loop, self-&gt;frontend);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  处理backend端的消息</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">s_handle_backend</span> <span class="params">(<span class="keyword">zloop_t</span> *loop, <span class="keyword">void</span> *socket, <span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//  使用worker的地址进行LRU路由</span></div><div class="line">    <span class="keyword">lruqueue_t</span> *self = (<span class="keyword">lruqueue_t</span> *) arg;</div><div class="line">    <span class="keyword">zmsg_t</span> *msg = zmsg_recv (self-&gt;backend);</div><div class="line">    <span class="keyword">if</span> (msg) &#123;</div><div class="line">        <span class="keyword">zframe_t</span> *address = zmsg_unwrap (msg);</div><div class="line">        zlist_append (self-&gt;workers, address);</div><div class="line"></div><div class="line">        <span class="comment">//  当有可用worker时增加frontend端的监听</span></div><div class="line">        <span class="keyword">if</span> (zlist_size (self-&gt;workers) == <span class="number">1</span>)</div><div class="line">            zloop_reader (loop, self-&gt;frontend, s_handle_frontend, self);</div><div class="line"></div><div class="line">        <span class="comment">//  如果是worker发送来的应答，则转发给client</span></div><div class="line">        <span class="keyword">zframe_t</span> *frame = zmsg_first (msg);</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span> (zframe_data (frame), LRU_READY, <span class="number">1</span>) == <span class="number">0</span>)</div><div class="line">            zmsg_destroy (&amp;msg);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            zmsg_send (&amp;msg, self-&gt;frontend);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">lruqueue_t</span> *self = (<span class="keyword">lruqueue_t</span> *) zmalloc (<span class="keyword">sizeof</span> (<span class="keyword">lruqueue_t</span>));</div><div class="line">    self-&gt;frontend = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    self-&gt;backend = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    zsocket_bind (self-&gt;frontend, <span class="string">"ipc://frontend.ipc"</span>);</div><div class="line">    zsocket_bind (self-&gt;backend, <span class="string">"ipc://backend.ipc"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> client_nbr;</div><div class="line">    <span class="keyword">for</span> (client_nbr = <span class="number">0</span>; client_nbr &lt; NBR_CLIENTS; client_nbr++)</div><div class="line">        zthread_new (ctx, client_task, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">int</span> worker_nbr;</div><div class="line">    <span class="keyword">for</span> (worker_nbr = <span class="number">0</span>; worker_nbr &lt; NBR_WORKERS; worker_nbr++)</div><div class="line">        zthread_new (ctx, worker_task, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  可用worker的列表</span></div><div class="line">    self-&gt;workers = zlist_new ();</div><div class="line"></div><div class="line">    <span class="comment">//  准备并启动反应器</span></div><div class="line">    <span class="keyword">zloop_t</span> *reactor = zloop_new ();</div><div class="line">    zloop_reader (reactor, self-&gt;backend, s_handle_backend, self);</div><div class="line">    zloop_start (reactor);</div><div class="line">    zloop_destroy (&amp;reactor);</div><div class="line"></div><div class="line">    <span class="comment">//  结束之后的清理工作</span></div><div class="line">    <span class="keyword">while</span> (zlist_size (self-&gt;workers)) &#123;</div><div class="line">        <span class="keyword">zframe_t</span> *frame = (<span class="keyword">zframe_t</span> *) zlist_pop (self-&gt;workers);</div><div class="line">        zframe_destroy (&amp;frame);</div><div class="line">    &#125;</div><div class="line">    zlist_destroy (&amp;self-&gt;workers);</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="built_in">free</span> (self);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要正确处理Ctrl-C还是有点困难的，如果你使用zctx类，那它会自动进行处理，不过也需要代码的配合。若zmq_poll()返回了-1，或者recv方法（zstr_recv, zframe_recv, zmsg_recv）返回了NULL，就必须退出所有的循环。另外，在最外层循环中增加!zctx_interrupted的判断也很有用。</p>
<h3 id="异步C-S结构"><a href="#异步C-S结构" class="headerlink" title="异步C/S结构"></a>异步C/S结构</h3><p>在之前的ROUTER-DEALER模型中，我们看到了client是如何异步地和多个worker进行通信的。我们可以将这个结构倒置过来，实现多个client异步地和单个server进行通信：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> +-----------+   +-----------+</div><div class="line"> |           |   |           |</div><div class="line"> |  Client   |   |  Client   |</div><div class="line"> |           |   |           |</div><div class="line"> +-----------+   +-----------+</div><div class="line"> |  DEALER   |   |  DEALER   |</div><div class="line"> \-----------/   \-----------/</div><div class="line">       ^               ^</div><div class="line">       |               |</div><div class="line">       |               |</div><div class="line">       +-------+-------+</div><div class="line">               |</div><div class="line">               |</div><div class="line">               v</div><div class="line">        /------+------\</div><div class="line">        |   ROUTER    |</div><div class="line">        +-------------+</div><div class="line">        |             |</div><div class="line">        |   Server    |</div><div class="line">        |             |</div><div class="line">        +-------------+</div><div class="line"></div><div class="line"></div><div class="line">Figure # - Asynchronous Client-Server</div></pre></td></tr></table></figure>
<ul>
<li>client连接至server并发送请求；</li>
<li>每一次收到请求，server会发送0至N个应答；</li>
<li>client可以同时发送多个请求而不需要等待应答；</li>
<li>server可以同时发送多个应答二不需要新的请求。</li>
</ul>
<p><strong>asyncsrd.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  异步C/S模型（DEALER-ROUTER）</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"czmq.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">//  ---------------------------------------------------------------------</span></div><div class="line"><span class="comment">//  这是client端任务，它会连接至server，每秒发送一次请求，同时收集和打印应答消息。</span></div><div class="line"><span class="comment">//  我们会运行多个client端任务，使用随机的标识。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">client_task</span> <span class="params">(<span class="keyword">void</span> *args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">void</span> *client = zsocket_new (ctx, ZMQ_DEALER);</div><div class="line"></div><div class="line">    <span class="comment">//  设置随机标识，方便跟踪</span></div><div class="line">    <span class="keyword">char</span> identity [<span class="number">10</span>];</div><div class="line">    <span class="built_in">sprintf</span> (identity, <span class="string">"%04X-%04X"</span>, randof (<span class="number">0x10000</span>), randof (<span class="number">0x10000</span>));</div><div class="line">    zsockopt_set_identity (client, identity);</div><div class="line">    zsocket_connect (client, <span class="string">"tcp://localhost:5570"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">zmq_pollitem_t</span> items [] = &#123; &#123; client, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125; &#125;;</div><div class="line">    <span class="keyword">int</span> request_nbr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//  从poll中获取消息，每秒一次</span></div><div class="line">        <span class="keyword">int</span> centitick;</div><div class="line">        <span class="keyword">for</span> (centitick = <span class="number">0</span>; centitick &lt; <span class="number">100</span>; centitick++) &#123;</div><div class="line">            zmq_poll (items, <span class="number">1</span>, <span class="number">10</span> * ZMQ_POLL_MSEC);</div><div class="line">            <span class="keyword">if</span> (items [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">                <span class="keyword">zmsg_t</span> *msg = zmsg_recv (client);</div><div class="line">                zframe_print (zmsg_last (msg), identity);</div><div class="line">                zmsg_destroy (&amp;msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        zstr_sendf (client, <span class="string">"request #%d"</span>, ++request_nbr);</div><div class="line">    &#125;</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  ---------------------------------------------------------------------</span></div><div class="line"><span class="comment">//  这是server端任务，它使用多线程机制将请求分发给多个worker，并正确返回应答信息。</span></div><div class="line"><span class="comment">//  一个worker只能处理一次请求，但client可以同时发送多个请求。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_worker</span> <span class="params">(<span class="keyword">void</span> *args, <span class="keyword">zctx_t</span> *ctx, <span class="keyword">void</span> *pipe)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">server_task</span> <span class="params">(<span class="keyword">void</span> *args)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line"></div><div class="line">    <span class="comment">//  frontend套接字使用TCP和client通信</span></div><div class="line">    <span class="keyword">void</span> *frontend = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    zsocket_bind (frontend, <span class="string">"tcp://*:5570"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  backend套接字使用inproc和worker通信</span></div><div class="line">    <span class="keyword">void</span> *backend = zsocket_new (ctx, ZMQ_DEALER);</div><div class="line">    zsocket_bind (backend, <span class="string">"inproc://backend"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  启动一个worker线程池，数量任意</span></div><div class="line">    <span class="keyword">int</span> thread_nbr;</div><div class="line">    <span class="keyword">for</span> (thread_nbr = <span class="number">0</span>; thread_nbr &lt; <span class="number">5</span>; thread_nbr++)</div><div class="line">        zthread_fork (ctx, server_worker, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  使用队列装置连接backend和frontend，我们本来可以这样做：</span></div><div class="line">    <span class="comment">//      zmq_device (ZMQ_QUEUE, frontend, backend);</span></div><div class="line">    <span class="comment">//  但这里我们会自己完成这个任务，这样可以方便调试。</span></div><div class="line"></div><div class="line">    <span class="comment">//  在frontend和backend间搬运消息</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">zmq_pollitem_t</span> items [] = &#123;</div><div class="line">            &#123; frontend, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</div><div class="line">            &#123; backend,  <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</div><div class="line">        &#125;;</div><div class="line">        zmq_poll (items, <span class="number">2</span>, <span class="number">-1</span>);</div><div class="line">        <span class="keyword">if</span> (items [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            <span class="keyword">zmsg_t</span> *msg = zmsg_recv (frontend);</div><div class="line">            <span class="comment">//puts ("Request from client:");</span></div><div class="line">            <span class="comment">//zmsg_dump (msg);</span></div><div class="line">            zmsg_send (&amp;msg, backend);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (items [<span class="number">1</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            <span class="keyword">zmsg_t</span> *msg = zmsg_recv (backend);</div><div class="line">            <span class="comment">//puts ("Reply from worker:");</span></div><div class="line">            <span class="comment">//zmsg_dump (msg);</span></div><div class="line">            zmsg_send (&amp;msg, frontend);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  接收一个请求，随机返回多条相同的文字，并在应答之间做随机的延迟。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">server_worker</span> <span class="params">(<span class="keyword">void</span> *args, <span class="keyword">zctx_t</span> *ctx, <span class="keyword">void</span> *pipe)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *worker = zsocket_new (ctx, ZMQ_DEALER);</div><div class="line">    zsocket_connect (worker, <span class="string">"inproc://backend"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//  DEALER套接字将信封和消息内容一起返回给我们</span></div><div class="line">        <span class="keyword">zmsg_t</span> *msg = zmsg_recv (worker);</div><div class="line">        <span class="keyword">zframe_t</span> *address = zmsg_pop (msg);</div><div class="line">        <span class="keyword">zframe_t</span> *content = zmsg_pop (msg);</div><div class="line">        assert (content);</div><div class="line">        zmsg_destroy (&amp;msg);</div><div class="line"></div><div class="line">        <span class="comment">//  随机返回0至4条应答</span></div><div class="line">        <span class="keyword">int</span> reply, replies = randof (<span class="number">5</span>);</div><div class="line">        <span class="keyword">for</span> (reply = <span class="number">0</span>; reply &lt; replies; reply++) &#123;</div><div class="line">            <span class="comment">//  暂停一段时间</span></div><div class="line">            zclock_sleep (randof (<span class="number">1000</span>) + <span class="number">1</span>);</div><div class="line">            zframe_send (&amp;address, worker, ZFRAME_REUSE + ZFRAME_MORE);</div><div class="line">            zframe_send (&amp;content, worker, ZFRAME_REUSE);</div><div class="line">        &#125;</div><div class="line">        zframe_destroy (&amp;address);</div><div class="line">        zframe_destroy (&amp;content);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//  主程序用来启动多个client和一个server</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    zthread_new (ctx, client_task, <span class="literal">NULL</span>);</div><div class="line">    zthread_new (ctx, client_task, <span class="literal">NULL</span>);</div><div class="line">    zthread_new (ctx, client_task, <span class="literal">NULL</span>);</div><div class="line">    zthread_new (ctx, server_task, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  运行5秒后退出</span></div><div class="line">    zclock_sleep (<span class="number">5</span> * <span class="number">1000</span>);</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行上面的代码，可以看到三个客户端有各自的随机标识，每次请求会获得零到多条回复。</p>
<ul>
<li><p>client每秒会发送一次请求，并获得零到多条应答。这要通过zmq_poll()来实现，但我们不能只每秒poll一次，这样将不能及时处理应答。程序中我们每秒取100次，这样一来server端也可以以此作为一种心跳（heartbeat），用来检测client是否还在线。</p>
</li>
<li><p>server使用了一个worker池，每一个worker同步处理一条请求。我们可以使用内置的队列来搬运消息，但为了方便调试，在程序中我们自己实现了这一过程。你可以将注释的几行去掉，看看输出结果。</p>
</li>
</ul>
<p>这段代码的整体架构如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">    +---------+   +---------+   +---------+</div><div class="line">    |         |   |         |   |         |</div><div class="line">    | Client  |   | Client  |   | Client  |</div><div class="line">    |         |   |         |   |         |</div><div class="line">    +---------+   +---------+   +---------+</div><div class="line">    | DEALER  |   | DEALER  |   | DEALER  |</div><div class="line">    \---------/   \---------/   \---------/</div><div class="line">      connect       connect       connect</div><div class="line">         |             |             |</div><div class="line">         |             |             |</div><div class="line">         +-------------+-------------+</div><div class="line">                       |</div><div class="line">/----------------------|----------------------\</div><div class="line">:                      v                      :</div><div class="line">:                    bind                     :</div><div class="line">:                /-----------\                :</div><div class="line">:                |  ROUTER   |                :</div><div class="line">:                +-----------+                :</div><div class="line">:                |           |                :</div><div class="line">:                |  Server   |                :</div><div class="line">:                |           |                :</div><div class="line">:                +-----------+                :</div><div class="line">:                |  DEALER   |                :</div><div class="line">:                \-----------/                :</div><div class="line">:                    bind                     :</div><div class="line">:                      |                      :</div><div class="line">:        +-------------+-------------+        :</div><div class="line">:        |             |             |        :</div><div class="line">:        v             v             v        :</div><div class="line">:     connect       connect       connect     :</div><div class="line">:   /---------\   /---------\   /---------\   :</div><div class="line">:   | DEALER  |   | DEALER  |   | DEALER  |   :</div><div class="line">:   +---------+   +---------+   +---------+   :</div><div class="line">:   |         |   |         |   |         |   :</div><div class="line">:   | Worker  |   | Worker  |   | Worker  |   :</div><div class="line">:   |         |   |         |   |         |   :</div><div class="line">:   +---------+   +---------+   +---------+   :</div><div class="line">:                                             :</div><div class="line">\---------------------------------------------/</div><div class="line"></div><div class="line">    Figure # - Detail of asynchronous server</div></pre></td></tr></table></figure>
<p>可以看到，client和server之间的连接我们使用的是DEALER-ROUTER，而server和worker的连接则用了DEALER-DEALER。如果worker是一个同步的线程，我们可以用REP。但是本例中worker需要能够发送多个应答，所以就需要使用DEALER这样的异步套接字。这里我们不需要对应答进行路由，因为所有的worker都是连接到一个server上的。</p>
<p>让我们看看路由用的信封，client发送了一条信息，server获取的信息中包含了client的地址，这样一来我们有两种可行的server-worker通信方案：</p>
<ul>
<li><p>worker收到未经标识的信息。我们使用显式声明的标识，配合ROUTER套接字来连接worker和server。这种设计需要worker提前告知ROUTER它的存在，这种LRU算法正是我们之前所讲述的。</p>
</li>
<li><p>worker收到含有标识的信息，并返回含有标识的应答。这就要求worker能够处理好信封。</p>
</li>
</ul>
<p>第二种涉及较为简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  client          server       frontend       worker</div><div class="line">[ DEALER ]&lt;----&gt;[ ROUTER &lt;----&gt; DEALER &lt;----&gt; DEALER ]</div><div class="line">          1 part         2 parts       2 parts</div></pre></td></tr></table></figure>
<p>当我们需要在client和server之间维持一个对话时，就会碰到一个经典的问题：client是不固定的，如果给每个client都保存一些消息，那系统资源很快就会耗尽。即使是和同一个client保持连接，因为使用的是瞬时的套接字（没有显式声明标识），那每次连接也相当于是一个新的连接。</p>
<p>想要在异步的请求中保存好client的信息，有以下几点需要注意：</p>
<ul>
<li>client需要发送心跳给server。本例中client每秒都会发送一个请求给server，这就是一种很可靠的心跳机制。</li>
<li>使用client的套接字标识来存储信息，这对瞬时和持久的套接字都有效；</li>
<li>检测停止心跳的client，如两秒内没有收到某个client的心跳，就将保存的状态丢弃。</li>
</ul>
<h3 id="实战：跨代理路由"><a href="#实战：跨代理路由" class="headerlink" title="实战：跨代理路由"></a>实战：跨代理路由</h3><p>让我们把目前所学到的知识综合起来，应用到实战中去。我们的大客户今天打来一个紧急电话，说是要构建一个大型的云计算设施。它要求这个云架构可以跨越多个数据中心，每个数据中心包含一组client和worker，且能共同协作。</p>
<p>我们坚信实践高于理论，所以就提议使用ZMQ搭建这样一个系统。我们的客户同意了，可能是因为他的确也想降低开发的成本，或是在推特上看到了太多ZMQ的好处。</p>
<h4 id="细节详述"><a href="#细节详述" class="headerlink" title="细节详述"></a>细节详述</h4><p>喝完几杯特浓咖啡，我们准备着手干了，但脑中有个理智的声音提醒我们应该在事前将问题分析清楚，然后再开始思考解决方案。云到底要做什么？我们如是问，客户这样回答：</p>
<ul>
<li><p>worker在不同的硬件上运作，但可以处理所有类型的任务。每个集群都有成百个worker，再乘以集群的个数，因此数量众多。</p>
</li>
<li><p>client向worker指派任务，每个任务都是独立的，每个client都希望能找到对应的worker来处理任务，越快越好。client是不固定的，来去频繁。</p>
</li>
<li><p>真正的难点在于，这个架构需要能够自如地添加和删除集群，附带着集群中的client和worker。</p>
</li>
<li><p>如果集群中没有可用的worker，它便会将任务分派给其他集群中可以用的worker。</p>
</li>
<li><p>client每次发送一个请求，并等待应答。如果X秒后他们没有获得应答，他们会重新发送请求。这一点我们不需要多做考虑，client端的API已经写好了。</p>
</li>
<li><p>worker每次处理一个请求，他们的行为非常简单。如果worker崩溃了，会有另外的脚本启动他们。</p>
</li>
</ul>
<p>听了以上的回答，我们又进一步追问：</p>
<ul>
<li><p>集群之间会有一个更上层的网络来连接他们对吗？客户说是的。</p>
</li>
<li><p>我们需要处理多大的吞吐量？客户说，每个集群约有一千个client，单个client每秒会发送10次请求。请求包含的内容很少，应答也很少，每个不超过1KB。</p>
</li>
</ul>
<p>我们进行了简单的计算，2500个client x 10次/秒 x 1000字节 x 双向 = 50MB/秒，或400Mb/秒，这对1Gb网络来说不成问题，可以使用TCP协议。</p>
<p>这样需求就很清晰了，不需要额外的硬件或协议来完成这件事，只要提供一个高效的路由算法，设计得缜密一些。我们首先从一个集群（数据中心）开始，然后思考如何来连接他们。</p>
<h4 id="单个集群的架构"><a href="#单个集群的架构" class="headerlink" title="单个集群的架构"></a>单个集群的架构</h4><p>worker和client是同步的，我们使用LRU算法来给worker分配任务。每个worker都是等价的，所以我们不需要考虑服务的问题。worker是匿名的，client不会和某个特定的worker进行通信，因而我们不需要保证消息的送达以及失败后的重试等。</p>
<p>鉴于上文提过的原因，client和worker是不会直接通信的，这样一来就无法动态地添加和删除节点了。所以，我们的基础模型会使用一个请求-应答模式中使用过的代理结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">+--------+  +--------+  +--------+</div><div class="line">| Client |  | Client |  | Client |</div><div class="line">+--------+  +--------+  +--------+</div><div class="line">|  REQ   |  |  REQ   |  |  REQ   |</div><div class="line">+---+----+  +---+----+  +---+----+</div><div class="line">    |           |           |</div><div class="line">    +-----------+-----------+</div><div class="line">                |</div><div class="line">+--------------------------------+</div><div class="line">|               |                |</div><div class="line">|         +-----+------+         |</div><div class="line">|         |   ROUTER   |         |</div><div class="line">|         +------------+         |</div><div class="line">|         | LRU Queue  |         |</div><div class="line">|         +------------+         |</div><div class="line">|         |   ROUTER   |         |</div><div class="line">|         +-----+------+         |</div><div class="line">|               |         Broker :</div><div class="line">+--------------------------------+</div><div class="line">                |</div><div class="line">                |</div><div class="line">    +-----------+-----------+</div><div class="line">    |           |           |</div><div class="line">+---+----+  +---+----+  +---+----+</div><div class="line">|  REQ   |  |  REQ   |  |  REQ   |</div><div class="line">+--------+  +--------+  +--------+</div><div class="line">| Worker |  | Worker |  | Worker |</div><div class="line">+--------+  +--------+  +--------+</div><div class="line"></div><div class="line"></div><div class="line"> Figure # - Cluster architecture</div></pre></td></tr></table></figure>
<h4 id="多个集群的架构"><a href="#多个集群的架构" class="headerlink" title="多个集群的架构"></a>多个集群的架构</h4><p>下面我们将集群扩充到多个，每个集群有自己的一组client和worker，并使用代理相连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">     Cluster 1          :          Cluster 2</div><div class="line">                        :</div><div class="line">                        :</div><div class="line">+---+  +---+  +---+     :     +---+  +---+  +---+</div><div class="line">| C |  | C |  | C |     :     | C |  | C |  | C |</div><div class="line">+-+-+  +-+-+  +-+-+     :     +-+-+  +-+-+  +-+-+</div><div class="line">  |      |      |       :       |      |      |</div><div class="line">  |      |      |       :       |      |      |</div><div class="line">+-+------+------+-+     :     +-+------+------+-+</div><div class="line">|     Broker      |     :     |     Broker      |</div><div class="line">+-+------+------+-+     :     +-+------+------+-+</div><div class="line">  |      |      |       :       |      |      |</div><div class="line">  |      |      |       :       |      |      |</div><div class="line">+-+-+  +-+-+  +-+-+     :     +-+-+  +-+-+  +-+-+</div><div class="line">| W |  | W |  | W |     :     | W |  | W |  | W |</div><div class="line">+---+  +---+  +---+     :     +---+  +---+  +---+</div><div class="line">                        :</div><div class="line"></div><div class="line">         Figure # - Multiple clusters</div></pre></td></tr></table></figure>
<p>问题在于：我们如何让一个集群的client和另一个集群的worker进行通信呢？有这样几种解决方案，我们来看看他们的优劣：</p>
<ul>
<li><p>client直接和多个代理相连接。优点在于我们可以不对代理和worker做改动，但client会变得复杂，并需要知悉整个架构的情况。如果我们想要添加第三或第四个集群，所有的client都会需要修改。我们相当于是将路由和容错功能写进client了，这并不是个好主意。</p>
</li>
<li><p>worker直接和多个代理相连接。可是REQ类型的worker不能做到这一点，它只能应答给某一个代理。如果改用REP套接字，这样就不能使用LRU算法的队列代理了。这点肯定不行，在我们的结构中必须用LRU算法来管理worker。还有个方法是使用ROUTER套接字，让我们暂且称之为方案1。</p>
</li>
<li><p>代理之间可以互相连接，这看上去不错，因为不需要增加过多的额外连接。虽然我们不能随意地添加代理，但这个问题可以暂不考虑。这种情况下，集群中的worker和client不必理会整体架构，当代理有剩余的工作能力时便会和其他代理通信。这是方案2。</p>
</li>
</ul>
<p>我们首先看看方案1，worker同时和多个代理进行通信：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">            Cluster 1          :         Cluster 2</div><div class="line">                               :</div><div class="line">                               :</div><div class="line">          |            |               |            |</div><div class="line">          +------------+               +------------+</div><div class="line">          |   ROUTER   |               |   ROUTER   |</div><div class="line">          +-----+------+               +-----+------+</div><div class="line">                |                            |</div><div class="line">      +---------|-+--=--------+--------------+</div><div class="line">      :         | :           :</div><div class="line">    +-----------+-----------+ :</div><div class="line">    | :         | :         | :</div><div class="line">    | :         | :         | :</div><div class="line">+---+-+--+  +---+-+--+  +---+-+--+</div><div class="line">| ROUTER |  | ROUTER |  | ROUTER |</div><div class="line">+--------+  +--------+  +--------+</div><div class="line">| Worker |  | Worker |  | Worker |</div><div class="line">+--------+  +--------+  +--------+</div><div class="line"></div><div class="line"></div><div class="line">     Figure # - Idea 1 - cross-connected workers</div></pre></td></tr></table></figure>
<p>这看上去很灵活，但却没有提供我们所需要的特性：client只有当集群中的worker不可用时才会去请求异地的worker。此外，worker的“已就绪”信号会同时发送给两个代理，这样就有可能同时获得两份任务。这个方案的失败还有一个原因：我们又将路由逻辑放在了边缘地带。</p>
<p>那来看看方案2，我们为各个代理建立连接，不修改worker和client：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">     Cluster 1          :          Cluster 2</div><div class="line">                        :</div><div class="line">                        :</div><div class="line">+---+  +---+  +---+     :     +---+  +---+  +---+</div><div class="line">| C |  | C |  | C |     :     | C |  | C |  | C |</div><div class="line">+-+-+  +-+-+  +-+-+     :     +-+-+  +-+-+  +-+-+</div><div class="line">  |      |      |       :       |      |      |</div><div class="line">  |      |      |       :       |      |      |</div><div class="line">+-+------+------+-+     :     +-+------+------+-+</div><div class="line">|     Broker      |&lt;---------&gt;|     Broker      |</div><div class="line">+-+------+------+-+     :     +-+------+------+-+</div><div class="line">  |      |      |       :       |      |      |</div><div class="line">  |      |      |       :       |      |      |</div><div class="line">+-+-+  +-+-+  +-+-+     :     +-+-+  +-+-+  +-+-+</div><div class="line">| W |  | W |  | W |     :     | W |  | W |  | W |</div><div class="line">+---+  +---+  +---+     :     +---+  +---+  +---+</div><div class="line">                        :</div><div class="line"></div><div class="line">Figure # - Idea 2 - brokers talking to each other</div></pre></td></tr></table></figure>
<p>这种设计的优势在于，我们只需要在一个地方解决问题就可以了，其他地方不需要修改。这就好像代理之间会秘密通信：伙计，我这儿有一些剩余的劳动力，如果你那儿忙不过来就跟我说，价钱好商量。</p>
<p>事实上，我们只不过是需要设计一种更为复杂的路由算法罢了：代理成为了其他代理的分包商。这种设计还有其他一些好处：</p>
<ul>
<li><p>在普通情况下（如只存在一个集群），这种设计的处理方式和原来没有区别，当有多个集群时再进行其他动作。</p>
</li>
<li><p>对于不同的工作我们可以使用不同的消息流模式，如使用不同的网络链接。</p>
</li>
<li><p>架构的扩充看起来也比较容易，如有必要我们还可以添加一个超级代理来完成调度工作。</p>
</li>
</ul>
<p>现在我们就开始编写代码。我们会将完整的集群写入一个进程，这样便于演示，而且稍作修改就能投入实际使用。这也是ZMQ的优美之处，你可以使用最小的开发模块来进行实验，最后方便地迁移到实际工程中。线程变成进程，消息模式和逻辑不需要改变。我们每个“集群”进程都包含client线程、worker线程、以及代理线程。</p>
<p>我们对基础模型应该已经很熟悉了：</p>
<ul>
<li>client线程使用REQ套接字，将请求发送给代理线程（ROUTER套接字）；</li>
<li>worker线程使用REQ套接字，处理并应答从代理线程（ROUTER套接字）收到的请求；</li>
<li>代理会使用LRU队列和路由机制来管理请求。</li>
</ul>
<h4 id="联邦模式和同伴模式"><a href="#联邦模式和同伴模式" class="headerlink" title="联邦模式和同伴模式"></a>联邦模式和同伴模式</h4><p>连接代理的方式有很多，我们需要斟酌一番。我们需要的功能是告诉其他代理“我这里还有空闲的worker”，然后开始接收并处理一些任务；我们还需要能够告诉其他代理“够了够了，我这边的工作量也满了”。这个过程不一定要十分完美，有时我们确实会接收超过承受能力的工作量，但仍能逐步地完成。</p>
<p>最简单的方式称为联邦，即代理充当其他代理的client和worker。我们可以将代理的前端套接字连接至其他代理的后端套接字，反之亦然。提示一下，ZMQ中是可以将一个套接字绑定到一个端点，同时又连接至另一个端点的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">      Cluster 1          :          Cluster 2</div><div class="line">                         :</div><div class="line">                         :</div><div class="line"> +---+  +---+            :             +---+  +---+</div><div class="line"> | C |  | C |            :             | C |  | C |</div><div class="line"> +-+-+  +-+-+    +----+  :  +-----+    +-+-+  +-+-+</div><div class="line">   |      |      |    |  :  |     |      |      |</div><div class="line">   |      |      |    |  :  |     |      |      |</div><div class="line"> +-+------+------+-+  |  :  |   +-+------+------+-+</div><div class="line"> |     Broker      |  |  :  |   |     Broker      |</div><div class="line"> +-+------+--------+  |  :  |   +--------+------+-+</div><div class="line">   |      |      ^    |  :  |     ^      |      |</div><div class="line">   |      |      |    |  :  |     |      |      |</div><div class="line"> +-+-+  +-+-+    |    +-----------+    +-+-+  +-+-+</div><div class="line"> | W |  | W |    |       :  |          | W |  | W |</div><div class="line"> +---+  +---+    +----------+          +---+  +---+</div><div class="line">                         :</div><div class="line"></div><div class="line">Figure # - Cross-connected brokers in federation model</div></pre></td></tr></table></figure>
<p>这种架构的逻辑会比较简单：当代理没有client时，它会告诉其他代理自己准备好了，并接收一个任务进行处理。但问题在于这种机制太简单了，联邦模式下的代理一次只能处理一个请求。如果client和worker是严格同步的，那么代理中的其他空闲worker将分配不到任务。我们需要的代理应该具备完全异步的特性。</p>
<p>但是，联邦模式对某些应用来说是非常好的，比如面向服务架构（SOA）。所以，先不要急着否定联邦模式，它只是不适用于LRU算法和集群负载均衡而已。</p>
<p>我们还有一种方式来连接代理：同伴模式。代理之间知道彼此的存在，并使用一个特殊的信道进行通信。我们逐步进行分析，假设有N个代理需要连接，每个代理则有N-1个同伴，所有代理都使用相同格式的消息进行通信。关于消息在代理之间的流通有两点需要注意：</p>
<ul>
<li><p>每个代理需要告知所有同伴自己有多少空闲的worker，这是一则简单的消息，只是一个不断更新的数字，很显然我们会使用PUB-SUB套接字。这样一来，每个代理都会打开一个PUB套接字，不断告知外界自身的信息；同时又会打开一个SUB套接字，获取其他代理的信息。</p>
</li>
<li><p>每个代理需要以某种方式将工作任务交给其他代理，并能获取应答，这个过程需要是异步的。我们会使用ROUTER-ROUTER套接字来实现，没有其他选择。每个代理会使用两个这样的ROUTER套接字，一个用于接收任务，另一个用于分发任务。如果不使用两个套接字，那就需要额外的逻辑来判别收到的是请求还是应答，这就需要在消息中加入更多的信息。</p>
</li>
</ul>
<p>另外还需要考虑的是代理和本地client和worker之间的通信。</p>
<h4 id="The-Naming-Ceremony"><a href="#The-Naming-Ceremony" class="headerlink" title="The Naming Ceremony"></a>The Naming Ceremony</h4><p>代理中有三个消息流，每个消息流使用两个套接字，因此一共需要使用六个套接字。为这些套接字取一组好名字很重要，这样我们就不会在来回切换的时候找不着北。套接字是有一定任务的，他们的所完成的工作可以是命名的一部分。这样，当我们日后再重新阅读这些代码时，就不会显得太过陌生了。</p>
<p>以下是我们使用的三个消息流：</p>
<ul>
<li>本地（local）的请求-应答消息流，实现代理和client、代理和worker之间的通信；</li>
<li>云端（cloud）的请求-应答消息流，实现代理和其同伴的通信；</li>
<li>状态（state）流，由代理和其同伴互相传递。</li>
</ul>
<p>能够找到一些有意义的、且长度相同的名字，会让我们的代码对得比较整齐。可能他们并没有太多关联，但久了自然会习惯。</p>
<p>每个消息流会有两个套接字，我们之前一直称为“前端（frontend）”和“后端（backend）”。这两个名字我们已经使用很多次了：前端会负责接受信息或任务；后端会发送信息或任务给同伴。从概念上说，消息流都是从前往后的，应答则是从后往前。</p>
<p>因此，我们决定使用以下的命名方式：</p>
<ul>
<li>localfe / localbe</li>
<li>cloudfe / cloudbe</li>
<li>statefe / statebe</li>
</ul>
<p>通信协议方面，我们全部使用ipc。使用这种协议的好处是，它能像tcp协议那样作为一种脱机通信协议来工作，而又不需要使用IP地址或DNS服务。对于ipc协议的端点，我们会命名为xxx-localfe/be、xxx-cloud、xxx-state，其中xxx代表集群的名称。</p>
<p>也许你会觉得这种命名方式太长了，还不如简单的叫s1、s2、s3……事实上，你的大脑并不是机器，阅读代码的时候不能立刻反应出变量的含义。而用上面这种“三个消息流，两个方向”的方式记忆，要比纯粹记忆“六个不同的套接字”来的方便。</p>
<p>以下是代理程序的套接字分布图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+---------+ +---------+ +---------+</div><div class="line">| Client  | | Broker  | | Broker  |</div><div class="line">|         | | cloudbe | | statebe |</div><div class="line">+---------+ +---------+ +---------+</div><div class="line">| connect | | connect | |  bind   |</div><div class="line">+---------+ +---------+ +---------+</div><div class="line">  request     request      state</div><div class="line">     |           |           |</div><div class="line">     +-+         |         +-+</div><div class="line">       |         |         |</div><div class="line">       v         v         v</div><div class="line">  +---------+---------+---------+</div><div class="line">  |  bind   |  bind   | connect |</div><div class="line">  +---------+---------+---------+</div><div class="line">  | localfe | cloudfe | statefe |     Frontends</div><div class="line">  | ROUTER  | ROUTER  |   SUB   |     (incoming)</div><div class="line">  +---------+---------+---------+</div><div class="line">  |                             |</div><div class="line">  |           Broker            |</div><div class="line">  |                             |</div><div class="line">  +---------+---------+---------+</div><div class="line">  | ROUTER  | ROUTER  |   PUB   |     Backends</div><div class="line">  | localbe | cloudbe | statebe |     (outgoing)</div><div class="line">  +---------+---------+---------+</div><div class="line">  |  bind   | connect |  bind   |</div><div class="line">  +---------+---------+---------+</div><div class="line">    request   request    state</div><div class="line">       |         |         |</div><div class="line">     +-+         |         +-+</div><div class="line">     |           |           |</div><div class="line">     v           v           v</div><div class="line">+---------+ +---------+ +---------+</div><div class="line">| connect | |  bind   | | connect |</div><div class="line">+---------+ +---------+ +---------+</div><div class="line">| Worker  | | Broker  | | Broker  |</div><div class="line">|         | | cloudfe | | statefe |</div><div class="line">+---------+ +---------+ +---------+</div><div class="line"></div><div class="line"></div><div class="line">Figure # - Broker socket arrangement</div></pre></td></tr></table></figure>
<p>请注意，我们会将cloudbe连接至其他代理的cloudfe，也会将statebe连接至其他代理的statefe。</p>
<h4 id="状态流原型"><a href="#状态流原型" class="headerlink" title="状态流原型"></a>状态流原型</h4><p>由于每个消息流都有其巧妙之处，所以我们不会直接把所有的代码都写出来，而是分段编写和测试。当每个消息流都能正常工作了，我们再将其拼装成一个完整的应用程序。我们首先从状态流开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">                      +---------+</div><div class="line">                      | Broker  |</div><div class="line">                      | statebe |</div><div class="line">                      +---------+</div><div class="line">                      |  bind   |</div><div class="line">                      +---------+</div><div class="line">                         state</div><div class="line">                           |</div><div class="line">                         +-+</div><div class="line">                         |</div><div class="line">                         v</div><div class="line">+---------+---------+---------+</div><div class="line">|         |         | connect |</div><div class="line">+---------+---------+---------+</div><div class="line">|         |         | statefe |</div><div class="line">|         |         |   SUB   |</div><div class="line">+---------+---------+---------+</div><div class="line">|                             |</div><div class="line">|           Broker            |</div><div class="line">|                             |</div><div class="line">+---------+---------+---------+</div><div class="line">|         |         |   PUB   |</div><div class="line">|         |         | statebe |</div><div class="line">+---------+---------+---------+</div><div class="line">|         |         |  bind   |</div><div class="line">+---------+---------+---------+</div><div class="line">                       state</div><div class="line">                         |</div><div class="line">                         +-+</div><div class="line">                           |</div><div class="line">                           v</div><div class="line">                      +---------+</div><div class="line">                      | connect |</div><div class="line">                      +---------+</div><div class="line">                      | statefe |</div><div class="line">                      | Broker  |</div><div class="line">                      +---------+</div><div class="line"></div><div class="line"></div><div class="line">  Figure # - The state flow</div></pre></td></tr></table></figure>
<p>代码如下：</p>
<p><strong>peering1: Prototype state flow in C</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  代理同伴模拟（第一部分）</span></div><div class="line"><span class="comment">//  状态流原型</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"czmq.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv [])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//  第一个参数是代理的名称</span></div><div class="line">    <span class="comment">//  其他参数是各个同伴的名称</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"syntax: peering1 me &#123;you&#125;...\n"</span>);</div><div class="line">        <span class="built_in">exit</span> (EXIT_FAILURE);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">char</span> *self = argv [<span class="number">1</span>];</div><div class="line">    <span class="built_in">printf</span> (<span class="string">"I: 正在准备代理程序 %s...\n"</span>, self);</div><div class="line">    srandom ((<span class="keyword">unsigned</span>) time (<span class="literal">NULL</span>));</div><div class="line"></div><div class="line">    <span class="comment">//  准备上下文和套接字</span></div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">void</span> *statebe = zsocket_new (ctx, ZMQ_PUB);</div><div class="line">    zsocket_bind (statebe, <span class="string">"ipc://%s-state.ipc"</span>, self);</div><div class="line"></div><div class="line">    <span class="comment">//  连接statefe套接字至所有同伴</span></div><div class="line">    <span class="keyword">void</span> *statefe = zsocket_new (ctx, ZMQ_SUB);</div><div class="line">    <span class="keyword">int</span> argn;</div><div class="line">    <span class="keyword">for</span> (argn = <span class="number">2</span>; argn &lt; argc; argn++) &#123;</div><div class="line">        <span class="keyword">char</span> *peer = argv [argn];</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"I: 正在连接至同伴代理 '%s' 的状态流后端\n"</span>, peer);</div><div class="line">        zsocket_connect (statefe, <span class="string">"ipc://%s-state.ipc"</span>, peer);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//  发送并接受状态消息</span></div><div class="line">    <span class="comment">//  zmq_poll()函数使用的超时时间即心跳时间</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//  初始化poll对象列表</span></div><div class="line">        <span class="keyword">zmq_pollitem_t</span> items [] = &#123;</div><div class="line">            &#123; statefe, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//  轮询套接字活动，超时时间为1秒</span></div><div class="line">        <span class="keyword">int</span> rc = zmq_poll (items, <span class="number">1</span>, <span class="number">1000</span> * ZMQ_POLL_MSEC);</div><div class="line">        <span class="keyword">if</span> (rc == <span class="number">-1</span>)</div><div class="line">            <span class="keyword">break</span>;              <span class="comment">//  中断</span></div><div class="line"></div><div class="line">        <span class="comment">//  处理接收到的状态消息</span></div><div class="line">        <span class="keyword">if</span> (items [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            <span class="keyword">char</span> *peer_name = zstr_recv (statefe);</div><div class="line">            <span class="keyword">char</span> *available = zstr_recv (statefe);</div><div class="line">            <span class="built_in">printf</span> (<span class="string">"同伴代理 %s 有 %s 个worker空闲\n"</span>, peer_name, available);</div><div class="line">            <span class="built_in">free</span> (peer_name);</div><div class="line">            <span class="built_in">free</span> (available);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//  发送随机数表示空闲的worker数</span></div><div class="line">            zstr_sendm (statebe, self);</div><div class="line">            zstr_sendf (statebe, <span class="string">"%d"</span>, randof (<span class="number">10</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>几点说明：</p>
<ul>
<li><p>每个代理都需要有各自的标识，用以生成相应的ipc端点名称。真实环境中，代理需要使用TCP协议连接，这就需要一个更为完备的配置机制，我们会在以后的章节中谈到。</p>
</li>
<li><p>程序的核心是一个zmq_poll()循环，它会处理接收到消息，并发送自身的状态。只有当zmq_poll()因无法获得同伴消息而超时时我们才会发送自身状态，如果我们每次收到消息都去发送自身状态，那消息就会过量了。</p>
</li>
<li><p>发送的状态消息包含两帧，第一帧是代理自身的地址，第二帧是空闲的worker数。我们必须要告知同伴代理自身的地址，这样才能接收到请求，唯一的方法就是在消息中显示注明。</p>
</li>
<li><p>我们没有在SUB套接字上设置标识，否则就会在连接到同伴代理时获得过期的状态信息。</p>
</li>
<li><p>我们没有在PUB套接字上设置阈值（HWM），因为订阅者是瞬时的。我们也可以将阈值设置为1，但其实是没有必要的。</p>
</li>
</ul>
<p>让我们编译这段程序，用它模拟三个集群，DC1、DC2、DC3。我们在不同的窗口中运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">peering1 DC1 DC2 DC3  #  Start DC1 and connect to DC2 and DC3</div><div class="line">peering1 DC2 DC1 DC3  #  Start DC2 and connect to DC1 and DC3</div><div class="line">peering1 DC3 DC1 DC2  #  Start DC3 and connect to DC1 and DC2</div></pre></td></tr></table></figure>
<p>每个集群都会报告同伴代理的状态，之后每隔一秒都会打印出自己的状态。</p>
<p>在现实编程中，我们不会通过定时的方式来发送自身状态，而是在状态发生改变时就发送。这看起来会很占用带宽，但其实状态消息的内容很少，而且集群间的连接是非常快速的。</p>
<p>如果我们想要以较为精确的周期来发送状态信息，可以新建一个线程，将statebe套接字打开，然后由主线程将不规则的状态信息发送给子线程，再由子线程定时发布这些消息。不过这种机制就需要额外的编程了。</p>
<h4 id="本地流和云端流原型"><a href="#本地流和云端流原型" class="headerlink" title="本地流和云端流原型"></a>本地流和云端流原型</h4><p>下面让我们建立本地流和云端流的原型。这段代码会从client获取请求，并随机地分派给集群内的worker或其他集群。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+---------+ +---------+</div><div class="line">| Client  | | Broker  |</div><div class="line">|         | | cloudbe |</div><div class="line">+---------+ +---------+</div><div class="line">| connect | | connect |</div><div class="line">+---------+ +---------+</div><div class="line">  request     request</div><div class="line">     |           |</div><div class="line">     +-+         |</div><div class="line">       |         |</div><div class="line">       v         v</div><div class="line">  +---------+---------+---------+</div><div class="line">  |  bind   |  bind   |         |</div><div class="line">  +---------+---------+---------+</div><div class="line">  | localfe | cloudfe |         |</div><div class="line">  | ROUTER  | ROUTER  |         |</div><div class="line">  +---------+---------+---------+</div><div class="line">  |                             |</div><div class="line">  |           Broker            |</div><div class="line">  |                             |</div><div class="line">  +---------+---------+---------+</div><div class="line">  | ROUTER  | ROUTER  |         |</div><div class="line">  | localbe | cloudbe |         |</div><div class="line">  +---------+---------+---------+</div><div class="line">  |  bind   | connect |         |</div><div class="line">  +---------+---------+---------+</div><div class="line">    request   request</div><div class="line">       |         |</div><div class="line">     +-+         |</div><div class="line">     |           |</div><div class="line">     v           v</div><div class="line">+---------+ +---------+</div><div class="line">| connect | |  bind   |</div><div class="line">+---------+ +---------+</div><div class="line">|         | | cloudfe |</div><div class="line">| Worker  | | Broker  |</div><div class="line">+---------+ +---------+</div><div class="line"></div><div class="line"></div><div class="line"> Figure # - The flow of tasks</div></pre></td></tr></table></figure>
<p>在编写代码之前，让我们先描绘一下核心的路由逻辑，整理出一份简单而健壮的设计。</p>
<p>我们需要两个队列，一个队列用于存放从本地集群client收到的请求，另一个存放其他集群发送来的请求。一种方法是从本地和云端的前端套接字中获取消息，分别存入两个队列。但是这么做似乎是没有必要的，因为ZMQ套接字本身就是队列。所以，我们直接使用ZMQ套接字提供的缓存来作为队列使用。</p>
<p>这项技术我们在LRU队列装置中使用过，且工作得很好。做法是，当代理下有空闲的worker或能接收请求的其他集群时，才从套接字中获取请求。我们可以不断地从后端获取应答，然后路由回去。如果后端没有任何响应，那也就没有必要去接收前端的请求了。</p>
<p>所以，我们的主循环会做以下几件事：</p>
<ul>
<li><p>轮询后端套接字，会从worker处获得“已就绪”的消息或是一个应答。如果是应答消息，则将其路由回集群client，或是其他集群。</p>
</li>
<li><p>worker应答后即可标记为可用，放入队列并计数；</p>
</li>
<li><p>如果有可用的worker，就获取一个请求，该请求可能来自集群内的client，也可能是其他集群。随后将请求转发给集群内的worker，或是随机转发给其他集群。</p>
</li>
</ul>
<p>这里我们只是随机地将请求发送给其他集群，而不是在代理中模拟出一个worker，进行集群间的任务分发。这看起来挺愚蠢的，不过目前尚可使用。</p>
<p>我们使用代理的标识来进行代理之前的消息路由。每个代理都有自己的名字，是在命令行中指定的。只要这些指定的名字和ZMQ为client自动生成的UUID不重复，那么我们就可以知道应答是要返回给client，还是返回给另一个集群。</p>
<p>下面是代码，有趣的部分已在程序中标注：</p>
<p><strong>peering2: Prototype local and cloud flow in C</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  代理同伴模拟（第二部分）</span></div><div class="line"><span class="comment">//  请求-应答消息流原型</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  示例程序使用了一个进程，这样可以让程序变得简单，</span></div><div class="line"><span class="comment">//  每个线程都有自己的上下文对象，所以可以认为他们是多个进程。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"czmq.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_CLIENTS 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_WORKERS 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_READY   <span class="meta-string">"\001"</span>      <span class="comment">//  消息：worker已就绪</span></span></div><div class="line"></div><div class="line"><span class="comment">//  代理名称；现实中，这个名称应该由某种配置完成</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> *self;</div><div class="line"></div><div class="line"><span class="comment">//  请求-应答客户端使用REQ套接字</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">client_task</span> <span class="params">(<span class="keyword">void</span> *args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">void</span> *client = zsocket_new (ctx, ZMQ_REQ);</div><div class="line">    zsocket_connect (client, <span class="string">"ipc://%s-localfe.ipc"</span>, self);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//  发送请求，接收应答</span></div><div class="line">        zstr_send (client, <span class="string">"HELLO"</span>);</div><div class="line">        <span class="keyword">char</span> *reply = zstr_recv (client);</div><div class="line">        <span class="keyword">if</span> (!reply)</div><div class="line">            <span class="keyword">break</span>;              <span class="comment">//  中断</span></div><div class="line">        <span class="built_in">printf</span> (<span class="string">"Client: %s\n"</span>, reply);</div><div class="line">        <span class="built_in">free</span> (reply);</div><div class="line">        sleep (<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  worker使用REQ套接字，并进行LRU路由</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">worker_task</span> <span class="params">(<span class="keyword">void</span> *args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">void</span> *worker = zsocket_new (ctx, ZMQ_REQ);</div><div class="line">    zsocket_connect (worker, <span class="string">"ipc://%s-localbe.ipc"</span>, self);</div><div class="line"></div><div class="line">    <span class="comment">//  告知代理worker已就绪</span></div><div class="line">    <span class="keyword">zframe_t</span> *frame = zframe_new (LRU_READY, <span class="number">1</span>);</div><div class="line">    zframe_send (&amp;frame, worker, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  处理消息</span></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">zmsg_t</span> *msg = zmsg_recv (worker);</div><div class="line">        <span class="keyword">if</span> (!msg)</div><div class="line">            <span class="keyword">break</span>;              <span class="comment">//  中断</span></div><div class="line"></div><div class="line">        zframe_print (zmsg_last (msg), <span class="string">"Worker: "</span>);</div><div class="line">        zframe_reset (zmsg_last (msg), <span class="string">"OK"</span>, <span class="number">2</span>);</div><div class="line">        zmsg_send (&amp;msg, worker);</div><div class="line">    &#125;</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv [])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//  第一个参数是代理的名称</span></div><div class="line">    <span class="comment">//  其他参数是同伴代理的名称</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"syntax: peering2 me &#123;you&#125;...\n"</span>);</div><div class="line">        <span class="built_in">exit</span> (EXIT_FAILURE);</div><div class="line">    &#125;</div><div class="line">    self = argv [<span class="number">1</span>];</div><div class="line">    <span class="built_in">printf</span> (<span class="string">"I: 正在准备代理程序 %s...\n"</span>, self);</div><div class="line">    srandom ((<span class="keyword">unsigned</span>) time (<span class="literal">NULL</span>));</div><div class="line"></div><div class="line">    <span class="comment">//  准备上下文和套接字</span></div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">char</span> endpoint [<span class="number">256</span>];</div><div class="line"></div><div class="line">    <span class="comment">//  将cloudfe绑定至端点</span></div><div class="line">    <span class="keyword">void</span> *cloudfe = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    zsockopt_set_identity (cloudfe, self);</div><div class="line">    zsocket_bind (cloudfe, <span class="string">"ipc://%s-cloud.ipc"</span>, self);</div><div class="line"></div><div class="line">    <span class="comment">//  将cloudbe连接至同伴代理的端点</span></div><div class="line">    <span class="keyword">void</span> *cloudbe = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    zsockopt_set_identity (cloudfe, self);</div><div class="line">    <span class="keyword">int</span> argn;</div><div class="line">    <span class="keyword">for</span> (argn = <span class="number">2</span>; argn &lt; argc; argn++) &#123;</div><div class="line">        <span class="keyword">char</span> *peer = argv [argn];</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"I: 正在连接至同伴代理 '%s' 的cloudfe端点\n"</span>, peer);</div><div class="line">        zsocket_connect (cloudbe, <span class="string">"ipc://%s-cloud.ipc"</span>, peer);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//  准备本地前端和后端</span></div><div class="line">    <span class="keyword">void</span> *localfe = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    zsocket_bind (localfe, <span class="string">"ipc://%s-localfe.ipc"</span>, self);</div><div class="line">    <span class="keyword">void</span> *localbe = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    zsocket_bind (localbe, <span class="string">"ipc://%s-localbe.ipc"</span>, self);</div><div class="line"></div><div class="line">    <span class="comment">//  让用户告诉我们何时开始</span></div><div class="line">    <span class="built_in">printf</span> (<span class="string">"请确认所有代理已经启动，按任意键继续: "</span>);</div><div class="line">    getchar ();</div><div class="line"></div><div class="line">    <span class="comment">//  启动本地worker</span></div><div class="line">    <span class="keyword">int</span> worker_nbr;</div><div class="line">    <span class="keyword">for</span> (worker_nbr = <span class="number">0</span>; worker_nbr &lt; NBR_WORKERS; worker_nbr++)</div><div class="line">        zthread_new (ctx, worker_task, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  启动本地client</span></div><div class="line">    <span class="keyword">int</span> client_nbr;</div><div class="line">    <span class="keyword">for</span> (client_nbr = <span class="number">0</span>; client_nbr &lt; NBR_CLIENTS; client_nbr++)</div><div class="line">        zthread_new (ctx, client_task, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  有趣的部分</span></div><div class="line">    <span class="comment">//  -------------------------------------------------------------</span></div><div class="line">    <span class="comment">//  请求-应答消息流</span></div><div class="line">    <span class="comment">//  - 若本地有可用worker，则轮询获取本地或云端的请求；</span></div><div class="line">    <span class="comment">//  - 将请求路由给本地worker或其他集群。</span></div><div class="line"></div><div class="line">    <span class="comment">//  可用worker队列</span></div><div class="line">    <span class="keyword">int</span> capacity = <span class="number">0</span>;</div><div class="line">    <span class="keyword">zlist_t</span> *workers = zlist_new ();</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">zmq_pollitem_t</span> backends [] = &#123;</div><div class="line">            &#123; localbe, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</div><div class="line">            &#123; cloudbe, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//  如果没有可用worker，则继续等待</span></div><div class="line">        <span class="keyword">int</span> rc = zmq_poll (backends, <span class="number">2</span>,</div><div class="line">            capacity? <span class="number">1000</span> * ZMQ_POLL_MSEC: <span class="number">-1</span>);</div><div class="line">        <span class="keyword">if</span> (rc == <span class="number">-1</span>)</div><div class="line">            <span class="keyword">break</span>;              <span class="comment">//  中断</span></div><div class="line"></div><div class="line">        <span class="comment">//  处理本地worker的应答</span></div><div class="line">        <span class="keyword">zmsg_t</span> *msg = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">if</span> (backends [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            msg = zmsg_recv (localbe);</div><div class="line">            <span class="keyword">if</span> (!msg)</div><div class="line">                <span class="keyword">break</span>;          <span class="comment">//  中断</span></div><div class="line">            <span class="keyword">zframe_t</span> *address = zmsg_unwrap (msg);</div><div class="line">            zlist_append (workers, address);</div><div class="line">            capacity++;</div><div class="line"></div><div class="line">            <span class="comment">//  如果是“已就绪”的信号，则不再进行路由</span></div><div class="line">            <span class="keyword">zframe_t</span> *frame = zmsg_first (msg);</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">memcmp</span> (zframe_data (frame), LRU_READY, <span class="number">1</span>) == <span class="number">0</span>)</div><div class="line">                zmsg_destroy (&amp;msg);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//  处理来自同伴代理的应答</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="keyword">if</span> (backends [<span class="number">1</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            msg = zmsg_recv (cloudbe);</div><div class="line">            <span class="keyword">if</span> (!msg)</div><div class="line">                <span class="keyword">break</span>;          <span class="comment">//  中断</span></div><div class="line">            <span class="comment">//  我们不需要使用同伴代理的地址</span></div><div class="line">            <span class="keyword">zframe_t</span> *address = zmsg_unwrap (msg);</div><div class="line">            zframe_destroy (&amp;address);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//  如果应答消息中的地址是同伴代理的，则发送给它</span></div><div class="line">        <span class="keyword">for</span> (argn = <span class="number">2</span>; msg &amp;&amp; argn &lt; argc; argn++) &#123;</div><div class="line">            <span class="keyword">char</span> *data = (<span class="keyword">char</span> *) zframe_data (zmsg_first (msg));</div><div class="line">            <span class="keyword">size_t</span> size = zframe_size (zmsg_first (msg));</div><div class="line">            <span class="keyword">if</span> (size == <span class="built_in">strlen</span> (argv [argn])</div><div class="line">            &amp;&amp;  <span class="built_in">memcmp</span> (data, argv [argn], size) == <span class="number">0</span>)</div><div class="line">                zmsg_send (&amp;msg, cloudfe);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//  将应答路由给本地client</span></div><div class="line">        <span class="keyword">if</span> (msg)</div><div class="line">            zmsg_send (&amp;msg, localfe);</div><div class="line"></div><div class="line">        <span class="comment">//  开始处理客户端请求</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keyword">while</span> (capacity) &#123;</div><div class="line">            <span class="keyword">zmq_pollitem_t</span> frontends [] = &#123;</div><div class="line">                &#123; localfe, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</div><div class="line">                &#123; cloudfe, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</div><div class="line">            &#125;;</div><div class="line">            rc = zmq_poll (frontends, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">            assert (rc &gt;= <span class="number">0</span>);</div><div class="line">            <span class="keyword">int</span> reroutable = <span class="number">0</span>;</div><div class="line">            <span class="comment">//  优先处理同伴代理的请求，避免资源耗尽</span></div><div class="line">            <span class="keyword">if</span> (frontends [<span class="number">1</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">                msg = zmsg_recv (cloudfe);</div><div class="line">                reroutable = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            <span class="keyword">if</span> (frontends [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">                msg = zmsg_recv (localfe);</div><div class="line">                reroutable = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;      <span class="comment">//  没有请求</span></div><div class="line"></div><div class="line">            <span class="comment">//  将20%的请求发送给其他集群</span></div><div class="line">            <span class="comment">//</span></div><div class="line">            <span class="keyword">if</span> (reroutable &amp;&amp; argc &gt; <span class="number">2</span> &amp;&amp; randof (<span class="number">5</span>) == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">//  随地地路由给同伴代理</span></div><div class="line">                <span class="keyword">int</span> random_peer = randof (argc - <span class="number">2</span>) + <span class="number">2</span>;</div><div class="line">                zmsg_pushmem (msg, argv [random_peer], <span class="built_in">strlen</span> (argv [random_peer]));</div><div class="line">                zmsg_send (&amp;msg, cloudbe);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">zframe_t</span> *frame = (<span class="keyword">zframe_t</span> *) zlist_pop (workers);</div><div class="line">                zmsg_wrap (msg, frame);</div><div class="line">                zmsg_send (&amp;msg, localbe);</div><div class="line">                capacity--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//  程序结束后的清理工作</span></div><div class="line">    <span class="keyword">while</span> (zlist_size (workers)) &#123;</div><div class="line">        <span class="keyword">zframe_t</span> *frame = (<span class="keyword">zframe_t</span> *) zlist_pop (workers);</div><div class="line">        zframe_destroy (&amp;frame);</div><div class="line">    &#125;</div><div class="line">    zlist_destroy (&amp;workers);</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在两个窗口中运行以上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">peering2 me you</div><div class="line">peering2 you me</div></pre></td></tr></table></figure>
<p>几点说明：</p>
<ul>
<li><p>zmsg类库让程序变得简单多了，这类程序显然应该成为我们ZMQ程序员必备的工具；<br>由于我们没有在程序中实现获取同伴代理状态的功能，所以先暂且认为他们都是有空闲worker的。现实中，我们不会将请求发送个一个不存在的同伴代理。</p>
</li>
<li><p>你可以让这段程序长时间地运行下去，看看会不会出现路由错误的消息，因为一旦错误，client就会阻塞。你可以试着将一个代理关闭，就能看到代理无法将请求路由给云端中的其他代理，client逐个阻塞，程序也停止打印跟踪信息。</p>
</li>
</ul>
<h4 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h4><p>让我们将所有这些放到一段代码里。和之前一样，我们会在一个进程中完成所有工作。我们会将上文中的两个示例程序结合起来，编写出一个可以模拟任意多个集群的程序。</p>
<p>代码共有270行，非常适合用来模拟一组完整的集群程序，包括client、worker、代理、以及云端任务分发机制。</p>
<p><strong>peering3: Full cluster simulation in C</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  同伴代理模拟（第三部分）</span></div><div class="line"><span class="comment">//  状态和任务消息流原型</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  示例程序使用了一个进程，这样可以让程序变得简单，</span></div><div class="line"><span class="comment">//  每个线程都有自己的上下文对象，所以可以认为他们是多个进程。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"czmq.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_CLIENTS 10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NBR_WORKERS 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_READY   <span class="meta-string">"\001"</span>      <span class="comment">//  消息：worker已就绪</span></span></div><div class="line"></div><div class="line"><span class="comment">//  代理名称；现实中，这个名称应该由某种配置完成</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> *self;</div><div class="line"></div><div class="line"><span class="comment">//  请求-应答客户端使用REQ套接字</span></div><div class="line"><span class="comment">//  为模拟压力测试，客户端会一次性发送大量请求</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">client_task</span> <span class="params">(<span class="keyword">void</span> *args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">void</span> *client = zsocket_new (ctx, ZMQ_REQ);</div><div class="line">    zsocket_connect (client, <span class="string">"ipc://%s-localfe.ipc"</span>, self);</div><div class="line">    <span class="keyword">void</span> *monitor = zsocket_new (ctx, ZMQ_PUSH);</div><div class="line">    zsocket_connect (monitor, <span class="string">"ipc://%s-monitor.ipc"</span>, self);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        sleep (randof (<span class="number">5</span>));</div><div class="line">        <span class="keyword">int</span> burst = randof (<span class="number">15</span>);</div><div class="line">        <span class="keyword">while</span> (burst--) &#123;</div><div class="line">            <span class="keyword">char</span> task_id [<span class="number">5</span>];</div><div class="line">            <span class="built_in">sprintf</span> (task_id, <span class="string">"%04X"</span>, randof (<span class="number">0x10000</span>));</div><div class="line"></div><div class="line">            <span class="comment">//  使用随机的十六进制ID来标注任务</span></div><div class="line">            zstr_send (client, task_id);</div><div class="line"></div><div class="line">            <span class="comment">//  最多等待10秒</span></div><div class="line">            <span class="keyword">zmq_pollitem_t</span> pollset [<span class="number">1</span>] = &#123; &#123; client, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125; &#125;;</div><div class="line">            <span class="keyword">int</span> rc = zmq_poll (pollset, <span class="number">1</span>, <span class="number">10</span> * <span class="number">1000</span> * ZMQ_POLL_MSEC);</div><div class="line">            <span class="keyword">if</span> (rc == <span class="number">-1</span>)</div><div class="line">                <span class="keyword">break</span>;          <span class="comment">//  中断</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (pollset [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">                <span class="keyword">char</span> *reply = zstr_recv (client);</div><div class="line">                <span class="keyword">if</span> (!reply)</div><div class="line">                    <span class="keyword">break</span>;              <span class="comment">//  中断</span></div><div class="line">                <span class="comment">//  worker的应答中应包含任务ID</span></div><div class="line">                <span class="built_in">puts</span> (reply);</div><div class="line">                assert (streq (reply, task_id));</div><div class="line">                <span class="built_in">free</span> (reply);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                zstr_sendf (monitor,</div><div class="line">                    <span class="string">"E: 客户端退出，丢失的任务为： %s"</span>, task_id);</div><div class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  worker使用REQ套接字，并进行LRU路由</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">worker_task</span> <span class="params">(<span class="keyword">void</span> *args)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">void</span> *worker = zsocket_new (ctx, ZMQ_REQ);</div><div class="line">    zsocket_connect (worker, <span class="string">"ipc://%s-localbe.ipc"</span>, self);</div><div class="line"></div><div class="line">    <span class="comment">//  告知代理worker已就绪</span></div><div class="line">    <span class="keyword">zframe_t</span> *frame = zframe_new (LRU_READY, <span class="number">1</span>);</div><div class="line">    zframe_send (&amp;frame, worker, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//  worker会随机延迟几秒</span></div><div class="line">        <span class="keyword">zmsg_t</span> *msg = zmsg_recv (worker);</div><div class="line">        sleep (randof (<span class="number">2</span>));</div><div class="line">        zmsg_send (&amp;msg, worker);</div><div class="line">    &#125;</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv [])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//  第一个参数是代理的名称</span></div><div class="line">    <span class="comment">//  其他参数是同伴代理的名称</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"syntax: peering3 me &#123;you&#125;...\n"</span>);</div><div class="line">        <span class="built_in">exit</span> (EXIT_FAILURE);</div><div class="line">    &#125;</div><div class="line">    self = argv [<span class="number">1</span>];</div><div class="line">    <span class="built_in">printf</span> (<span class="string">"I: 正在准备代理程序 %s...\n"</span>, self);</div><div class="line">    srandom ((<span class="keyword">unsigned</span>) time (<span class="literal">NULL</span>));</div><div class="line"></div><div class="line">    <span class="comment">//  准备上下文和套接字</span></div><div class="line">    <span class="keyword">zctx_t</span> *ctx = zctx_new ();</div><div class="line">    <span class="keyword">char</span> endpoint [<span class="number">256</span>];</div><div class="line"></div><div class="line">    <span class="comment">//  将cloudfe绑定至端点</span></div><div class="line">    <span class="keyword">void</span> *cloudfe = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    zsockopt_set_identity (cloudfe, self);</div><div class="line">    zsocket_bind (cloudfe, <span class="string">"ipc://%s-cloud.ipc"</span>, self);</div><div class="line"></div><div class="line">    <span class="comment">//  将statebe绑定至端点</span></div><div class="line">    <span class="keyword">void</span> *statebe = zsocket_new (ctx, ZMQ_PUB);</div><div class="line">    zsocket_bind (statebe, <span class="string">"ipc://%s-state.ipc"</span>, self);</div><div class="line"></div><div class="line">    <span class="comment">//  将cloudbe连接至同伴代理的端点</span></div><div class="line">    <span class="keyword">void</span> *cloudbe = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    zsockopt_set_identity (cloudbe, self);</div><div class="line">    <span class="keyword">int</span> argn;</div><div class="line">    <span class="keyword">for</span> (argn = <span class="number">2</span>; argn &lt; argc; argn++) &#123;</div><div class="line">        <span class="keyword">char</span> *peer = argv [argn];</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"I: 正在连接至同伴代理 '%s' 的cloudfe端点\n"</span>, peer);</div><div class="line">        zsocket_connect (cloudbe, <span class="string">"ipc://%s-cloud.ipc"</span>, peer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//  将statefe连接至同伴代理的端点</span></div><div class="line">    <span class="keyword">void</span> *statefe = zsocket_new (ctx, ZMQ_SUB);</div><div class="line">    <span class="keyword">for</span> (argn = <span class="number">2</span>; argn &lt; argc; argn++) &#123;</div><div class="line">        <span class="keyword">char</span> *peer = argv [argn];</div><div class="line">        <span class="built_in">printf</span> (<span class="string">"I: 正在连接至同伴代理 '%s' 的statebe端点\n"</span>, peer);</div><div class="line">        zsocket_connect (statefe, <span class="string">"ipc://%s-state.ipc"</span>, peer);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//  准备本地前端和后端</span></div><div class="line">    <span class="keyword">void</span> *localfe = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    zsocket_bind (localfe, <span class="string">"ipc://%s-localfe.ipc"</span>, self);</div><div class="line"></div><div class="line">    <span class="keyword">void</span> *localbe = zsocket_new (ctx, ZMQ_ROUTER);</div><div class="line">    zsocket_bind (localbe, <span class="string">"ipc://%s-localbe.ipc"</span>, self);</div><div class="line"></div><div class="line">    <span class="comment">//  准备监控套接字</span></div><div class="line">    <span class="keyword">void</span> *monitor = zsocket_new (ctx, ZMQ_PULL);</div><div class="line">    zsocket_bind (monitor, <span class="string">"ipc://%s-monitor.ipc"</span>, self);</div><div class="line"></div><div class="line">    <span class="comment">//  启动本地worker</span></div><div class="line">    <span class="keyword">int</span> worker_nbr;</div><div class="line">    <span class="keyword">for</span> (worker_nbr = <span class="number">0</span>; worker_nbr &lt; NBR_WORKERS; worker_nbr++)</div><div class="line">        zthread_new (ctx, worker_task, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  启动本地client</span></div><div class="line">    <span class="keyword">int</span> client_nbr;</div><div class="line">    <span class="keyword">for</span> (client_nbr = <span class="number">0</span>; client_nbr &lt; NBR_CLIENTS; client_nbr++)</div><div class="line">        zthread_new (ctx, client_task, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">//  有趣的部分</span></div><div class="line">    <span class="comment">//  -------------------------------------------------------------</span></div><div class="line">    <span class="comment">//  发布-订阅消息流</span></div><div class="line">    <span class="comment">//  - 轮询同伴代理的状态信息；</span></div><div class="line">    <span class="comment">//  - 当自身状态改变时，对外广播消息。</span></div><div class="line">    <span class="comment">//  请求-应答消息流</span></div><div class="line">    <span class="comment">//  - 若本地有可用worker，则轮询获取本地或云端的请求；</span></div><div class="line">    <span class="comment">//  - 将请求路由给本地worker或其他集群。</span></div><div class="line"></div><div class="line">    <span class="comment">//  可用worker队列</span></div><div class="line">    <span class="keyword">int</span> local_capacity = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> cloud_capacity = <span class="number">0</span>;</div><div class="line">    <span class="keyword">zlist_t</span> *workers = zlist_new ();</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">zmq_pollitem_t</span> primary [] = &#123;</div><div class="line">            &#123; localbe, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</div><div class="line">            &#123; cloudbe, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</div><div class="line">            &#123; statefe, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</div><div class="line">            &#123; monitor, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//  如果没有可用的worker，则一直等待</span></div><div class="line">        <span class="keyword">int</span> rc = zmq_poll (primary, <span class="number">4</span>,</div><div class="line">            local_capacity? <span class="number">1000</span> * ZMQ_POLL_MSEC: <span class="number">-1</span>);</div><div class="line">        <span class="keyword">if</span> (rc == <span class="number">-1</span>)</div><div class="line">            <span class="keyword">break</span>;              <span class="comment">//  中断</span></div><div class="line"></div><div class="line">        <span class="comment">//  跟踪自身状态信息是否改变</span></div><div class="line">        <span class="keyword">int</span> previous = local_capacity;</div><div class="line"></div><div class="line">        <span class="comment">//  处理本地worker的应答</span></div><div class="line">        <span class="keyword">zmsg_t</span> *msg = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (primary [<span class="number">0</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            msg = zmsg_recv (localbe);</div><div class="line">            <span class="keyword">if</span> (!msg)</div><div class="line">                <span class="keyword">break</span>;          <span class="comment">//  中断</span></div><div class="line">            <span class="keyword">zframe_t</span> *address = zmsg_unwrap (msg);</div><div class="line">            zlist_append (workers, address);</div><div class="line">            local_capacity++;</div><div class="line"></div><div class="line">            <span class="comment">//  如果是“已就绪”的信号，则不再进行路由</span></div><div class="line">            <span class="keyword">zframe_t</span> *frame = zmsg_first (msg);</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">memcmp</span> (zframe_data (frame), LRU_READY, <span class="number">1</span>) == <span class="number">0</span>)</div><div class="line">                zmsg_destroy (&amp;msg);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//  处理来自同伴代理的应答</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="keyword">if</span> (primary [<span class="number">1</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            msg = zmsg_recv (cloudbe);</div><div class="line">            <span class="keyword">if</span> (!msg)</div><div class="line">                <span class="keyword">break</span>;          <span class="comment">//  Interrupted</span></div><div class="line">            <span class="comment">//  我们不需要使用同伴代理的地址</span></div><div class="line">            <span class="keyword">zframe_t</span> *address = zmsg_unwrap (msg);</div><div class="line">            zframe_destroy (&amp;address);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//  如果应答消息中的地址是同伴代理的，则发送给它</span></div><div class="line">        <span class="keyword">for</span> (argn = <span class="number">2</span>; msg &amp;&amp; argn &lt; argc; argn++) &#123;</div><div class="line">            <span class="keyword">char</span> *data = (<span class="keyword">char</span> *) zframe_data (zmsg_first (msg));</div><div class="line">            <span class="keyword">size_t</span> size = zframe_size (zmsg_first (msg));</div><div class="line">            <span class="keyword">if</span> (size == <span class="built_in">strlen</span> (argv [argn])</div><div class="line">            &amp;&amp;  <span class="built_in">memcmp</span> (data, argv [argn], size) == <span class="number">0</span>)</div><div class="line">                zmsg_send (&amp;msg, cloudfe);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//  将应答路由给本地client</span></div><div class="line">        <span class="keyword">if</span> (msg)</div><div class="line">            zmsg_send (&amp;msg, localfe);</div><div class="line"></div><div class="line">        <span class="comment">//  处理同伴代理的状态更新</span></div><div class="line">        <span class="keyword">if</span> (primary [<span class="number">2</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            <span class="keyword">char</span> *status = zstr_recv (statefe);</div><div class="line">            cloud_capacity = atoi (status);</div><div class="line">            <span class="built_in">free</span> (status);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//  处理监控消息</span></div><div class="line">        <span class="keyword">if</span> (primary [<span class="number">3</span>].revents &amp; ZMQ_POLLIN) &#123;</div><div class="line">            <span class="keyword">char</span> *status = zstr_recv (monitor);</div><div class="line">            <span class="built_in">printf</span> (<span class="string">"%s\n"</span>, status);</div><div class="line">            <span class="built_in">free</span> (status);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//  开始处理客户端请求</span></div><div class="line">        <span class="comment">//  - 如果本地有空闲worker，则总本地client和云端接收请求；</span></div><div class="line">        <span class="comment">//  - 如果我们只有空闲的同伴代理，则只轮询本地client的请求；</span></div><div class="line">        <span class="comment">//  - 将请求路由给本地worker，或者同伴代理。</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keyword">while</span> (local_capacity + cloud_capacity) &#123;</div><div class="line">            <span class="keyword">zmq_pollitem_t</span> secondary [] = &#123;</div><div class="line">                &#123; localfe, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;,</div><div class="line">                &#123; cloudfe, <span class="number">0</span>, ZMQ_POLLIN, <span class="number">0</span> &#125;</div><div class="line">            &#125;;</div><div class="line">            <span class="keyword">if</span> (local_capacity)</div><div class="line">                rc = zmq_poll (secondary, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                rc = zmq_poll (secondary, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">            assert (rc &gt;= <span class="number">0</span>);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (secondary [<span class="number">0</span>].revents &amp; ZMQ_POLLIN)</div><div class="line">                msg = zmsg_recv (localfe);</div><div class="line">            <span class="keyword">else</span></div><div class="line">            <span class="keyword">if</span> (secondary [<span class="number">1</span>].revents &amp; ZMQ_POLLIN)</div><div class="line">                msg = zmsg_recv (cloudfe);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;      <span class="comment">//  没有任务</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (local_capacity) &#123;</div><div class="line">                <span class="keyword">zframe_t</span> *frame = (<span class="keyword">zframe_t</span> *) zlist_pop (workers);</div><div class="line">                zmsg_wrap (msg, frame);</div><div class="line">                zmsg_send (&amp;msg, localbe);</div><div class="line">                local_capacity--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//  随机路由给同伴代理</span></div><div class="line">                <span class="keyword">int</span> random_peer = randof (argc - <span class="number">2</span>) + <span class="number">2</span>;</div><div class="line">                zmsg_pushmem (msg, argv [random_peer], <span class="built_in">strlen</span> (argv [random_peer]));</div><div class="line">                zmsg_send (&amp;msg, cloudbe);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (local_capacity != previous) &#123;</div><div class="line">            <span class="comment">//  将自身代理的地址附加到消息中</span></div><div class="line">            zstr_sendm (statebe, self);</div><div class="line">            <span class="comment">//  广播新的状态信息</span></div><div class="line">            zstr_sendf (statebe, <span class="string">"%d"</span>, local_capacity);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//  程序结束后的清理工作</span></div><div class="line">    <span class="keyword">while</span> (zlist_size (workers)) &#123;</div><div class="line">        <span class="keyword">zframe_t</span> *frame = (<span class="keyword">zframe_t</span> *) zlist_pop (workers);</div><div class="line">        zframe_destroy (&amp;frame);</div><div class="line">    &#125;</div><div class="line">    zlist_destroy (&amp;workers);</div><div class="line">    zctx_destroy (&amp;ctx);</div><div class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码并不长，但花费了大约一天的时间去调通。以下是一些说明：</p>
<ul>
<li><p>client线程会检测并报告失败的请求，它们会轮询代理套接字，查看是否有应答，超时时间为10秒。</p>
</li>
<li><p>client线程不会自己打印信息，而是将消息PUSH给一个监控线程，由它打印消息。这是我们第一次使用ZMQ进行监控和记录日志，我们以后会见得更多。</p>
</li>
<li><p>clinet会模拟多种负载情况，让集群在不同的压力下工作，因此请求可能会在本地处理，也有可能会发送至云端。集群中的client和worker数量、其他集群的数量，以及延迟时间，会左右这个结果。你可以设置不同的参数来测试它们。</p>
</li>
<li><p>主循环中有两组轮询集合，事实上我们可以使用三个：信息流、后端、前端。因为在前面的例子中，如果后端没有空闲的worker，就没有必要轮询前端请求了。</p>
</li>
</ul>
<p>以下是几个在编写过程中遇到的问题：</p>
<ul>
<li><p>如果请求或应答在某处丢失，client会因此阻塞。回忆以下，ROUTER-ROUTER套接字会在消息如法路由的情况下直接丢弃。这里的一个策略就是改变client线程，检测并报告这种错误。此外，我还在每次recv()之后以及send()之前使用zmsg_dump()来打印套接字内容，用来更快地定位消息。</p>
</li>
<li><p>主循环会错误地从多个已就绪的套接字中获取消息，造成第一条消息的丢失。解决方法是只从第一个已就绪的套接字中获取消息。</p>
</li>
<li><p>zmsg类库没有很好地将UUID编码为C语言字符串，导致包含字节0的UUID会崩溃。解决方法是将UUID转换成可打印的十六进制字符串。</p>
</li>
</ul>
<p>这段模拟程序没有检测同伴代理是否存在。如果你开启了某个代理，它已向其他代理发送过状态信息，然后关闭了，那其他代理仍会向它发送请求。这样一来，其他代理的client就会报告很多错误。解决时有两点：一、为状态信息设置有效期，当同伴代理消失一段时间后就不再发送请求；二、提高请求-应答的可靠性，这在下一章中会讲到。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/02/zmq-chapter4/" rel="next" title="zmq-chapter4">
                <i class="fa fa-chevron-left"></i> zmq-chapter4
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/01/zmq-chapter2/" rel="prev" title="zmq-chapter2">
                zmq-chapter2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="徐松" />
          <p class="site-author-name" itemprop="name">徐松</p>
           
              <p class="site-description motion-element" itemprop="description">天黑请闭眼</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-高级请求-应答模式"><span class="nav-number">1.</span> <span class="nav-text">第三章 高级请求-应答模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Request-Reply-Envelopes"><span class="nav-number">1.1.</span> <span class="nav-text">Request-Reply Envelopes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义请求-应答路由"><span class="nav-number">1.2.</span> <span class="nav-text">自定义请求-应答路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ROUTER-DEALER路由"><span class="nav-number">1.3.</span> <span class="nav-text">ROUTER-DEALER路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最近最少使用算法路由（LRU模式）"><span class="nav-number">1.4.</span> <span class="nav-text">最近最少使用算法路由（LRU模式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用地址进行路由"><span class="nav-number">1.5.</span> <span class="nav-text">使用地址进行路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请求-应答模式下的消息代理"><span class="nav-number">1.6.</span> <span class="nav-text">请求-应答模式下的消息代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OMQ上层API的封装"><span class="nav-number">1.7.</span> <span class="nav-text">ØMQ上层API的封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步C-S结构"><span class="nav-number">1.8.</span> <span class="nav-text">异步C/S结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实战：跨代理路由"><span class="nav-number">1.9.</span> <span class="nav-text">实战：跨代理路由</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#细节详述"><span class="nav-number">1.9.1.</span> <span class="nav-text">细节详述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单个集群的架构"><span class="nav-number">1.9.2.</span> <span class="nav-text">单个集群的架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个集群的架构"><span class="nav-number">1.9.3.</span> <span class="nav-text">多个集群的架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#联邦模式和同伴模式"><span class="nav-number">1.9.4.</span> <span class="nav-text">联邦模式和同伴模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Naming-Ceremony"><span class="nav-number">1.9.5.</span> <span class="nav-text">The Naming Ceremony</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#状态流原型"><span class="nav-number">1.9.6.</span> <span class="nav-text">状态流原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本地流和云端流原型"><span class="nav-number">1.9.7.</span> <span class="nav-text">本地流和云端流原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组装"><span class="nav-number">1.9.8.</span> <span class="nav-text">组装</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">徐松</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
